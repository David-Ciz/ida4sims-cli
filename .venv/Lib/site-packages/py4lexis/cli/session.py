import os
import platform
import subprocess
import time
from typing import Optional
import sys
import signal

from typing_extensions import Annotated
from py4lexis.core.session import (
    LexisSessionURL,
    LexisSessionCredentials,
    LexisSessionOffline
)
import typer


def _get_shell_for_platform():
    current_platform=platform.system()
    if current_platform == "Linux" or current_platform == "Darwin":
        # Use bash for Linux and macOS (Darwin is the name for macOS)
        return "bash"
    elif current_platform == "Windows":
        return "powershell"
    else:
        raise RuntimeError(f"Unsupported platform: {current_platform}")



app = typer.Typer(name="session",
                  help="Holds commands to instantiate LEXIS session. Type '[b]python -m py4lexis.cli session --help[/b]' to see list of available commands.",
                  rich_markup_mode="rich")


@app.command(
    help="Initialize Lexis Session in CLI via [b]URL[/b], i.e., provides login via LEXIS login page. After authentication, new inner '[b]batch/terminal/powershell[/b]' will be opened with a new defined environment variable " +
         "'[b]PY4LEXIS_TOKEN[/b]' holding user's refresh/offline token. If '[b]offline_acces[/b]' is set to '[b]True[/b]' '[b]PY4LEXIS_TOKEN[/b]' will be represented as '[b]OFFLINE_TOKEN[/b]'. Thus, use '[b]logout()[/b]' command to clear " + 
         "the session using offline token at the end of your work, please."
)
def login_url(offline_access: Annotated[bool, typer.Option(help="If '[b]True[/b]' offline token will be generated as refresh token.")]=False,
              auth_url: Annotated[Optional[str], typer.Option(help="URL used for authorization.")]=None,
              realm: Annotated[Optional[str], typer.Option(help="Realm used for authorization.")]=None,
              zone: Annotated[Optional[str], typer.Option(help="Zone used for authorization. By default 'IT4I iRODS zone'.")]=None,
              log_file: Annotated[Optional[str], typer.Option(help="Path used to save Py4LEXIS logs. By default './lexis_logs.log'")]=None,
              exit_on_error: Annotated[bool, typer.Option(help="If True, program will exit() on error.")]=True) -> None:
    session: LexisSessionURL = LexisSessionURL(auth_url=auth_url,
                                               realm=realm,
                                               zone=zone,
                                               log_file=log_file,
                                               in_cli=True,
                                               offline_access=offline_access,
                                               exit_on_error=exit_on_error)
    print("\n WARNING: LexisSession in CLI saves user's token to environment variable 'PY4LEXIS_TOKEN', use 'logout()' command to clear the session at the end of your work, please.\n")
    print("\n Inner console will start soon...\n")
    time.sleep(5)
    environment_snapshot: dict = os.environ
    environment_snapshot.update({"PY4LEXIS_TOKEN": session.get_refresh_token()})
    
    shell_type = _get_shell_for_platform()    
    
    subprocess.call(shell_type, env=environment_snapshot)
    
    return None


@app.command(
    help="Initialize Lexis Session in CLI via user's LEXIS credentials. After authentication, new inner '[b]batch/terminal/powershell[/b]' will be opened with a new defined environment variable " +
         "'[b]PY4LEXIS_TOKEN[/b]' holding user's refresh/offline token. If '[b]offline_acces[/b]' is set to '[b]True[/b]' '[b]PY4LEXIS_TOKEN[/b]' will be represented as '[b]OFFLINE_TOKEN[/b]'. Thus, use '[b]logout()[/b]' command to clear " + 
         "the session using offline token at the end of your work, please."
)
def login_credentials(offline_access: Annotated[bool, typer.Option(help="If '[b]True[/b]' offline token will be generated as refresh token.")]=False,
                      username: Annotated[Optional[str], typer.Option(help="Username used for LEXIS Credentials")]=None,
                      password: Annotated[Optional[str], typer.Option(help="Password used for LEXIS Credentials")]=None,
                      auth_url: Annotated[Optional[str], typer.Option(help="URL used for authorization.")]=None,
                      realm: Annotated[Optional[str], typer.Option(help="Realm used for authorization.")]=None,
                      zone: Annotated[Optional[str], typer.Option(help="Zone used for authorization. By default 'IT4I iRODS zone'.")]=None,
                      log_file: Annotated[Optional[str], typer.Option(help="Path used to save Py4LEXIS logs. By default './lexis_logs.log'")]=None,
                      exit_on_error: Annotated[bool, typer.Option(help="If True, program will exit() on error.")]=True) -> None:
    session: LexisSessionCredentials = LexisSessionCredentials(auth_url=auth_url,
                                                               realm=realm,
                                                               zone=zone,
                                                               log_file=log_file,
                                                               in_cli=True,
                                                               offline_access=offline_access,
                                                               username=username,
                                                               password=password,
                                                               exit_on_error=exit_on_error)
    print("\n WARNING: LexisSession in CLI saves user's token to environment variable 'PY4LEXIS_TOKEN', use 'logout()' command to clear the session at the end of your work, please.\n")
    print("\n Inner console will start soon...\n")
    time.sleep(5)
    environment_snapshot: dict = os.environ
    environment_snapshot.update({"PY4LEXIS_TOKEN": session.get_refresh_token()})
    
    shell_type = _get_shell_for_platform()    
    
    subprocess.call(shell_type, env=environment_snapshot)
    
    return None


@app.command(
    help="Initialize Lexis Session using user's offline (refresh) token. After authentication, new inner '[b]batch/terminal/powershell[/b]' will be opened with a new defined environment variable " +
         "'[b]PY4LEXIS_TOKEN[/b]' holding user's refresh/offline token. If '[b]offline_acces[/b]' is set to '[b]True[/b]' '[b]PY4LEXIS_TOKEN[/b]' will be represented as '[b]OFFLINE_TOKEN[/b]'. Thus, use '[b]logout()[/b]' command to clear " + 
         "the session using offline token at the end of your work, please."
)
def login_offline(token: Annotated[bool, typer.Argument(help="User's offline (refresh) token.")],
                  auth_url: Annotated[Optional[str], typer.Option(help="URL used for authorization.")]=None,
                  realm: Annotated[Optional[str], typer.Option(help="Realm used for authorization.")]=None,
                  zone: Annotated[Optional[str], typer.Option(help="Zone used for authorization. By default 'IT4I iRODS zone'.")]=None,
                  log_file: Annotated[Optional[str], typer.Option(help="Path used to save Py4LEXIS logs. By default './lexis_logs.log'")]=None,
                  exit_on_error: Annotated[bool, typer.Option(help="If True, program will exit() on error.")]=True) -> None:
    session: LexisSessionCredentials = LexisSessionOffline(auth_url=auth_url,
                                                           realm=realm,
                                                           zone=zone,
                                                           log_file=log_file,
                                                           in_cli=True,
                                                           refresh_token=token,
                                                           exit_on_error=exit_on_error)
    print("\n WARNING: LexisSession in CLI saves user's token to environment variable 'PY4LEXIS_TOKEN', use 'logout()' command to clear the session at the end of your work, please.\n")
    print("\n Inner console will start soon...\n")
    time.sleep(5)
    environment_snapshot: dict = os.environ
    environment_snapshot.update({"PY4LEXIS_TOKEN": session.get_refresh_token()})
    
    shell_type = _get_shell_for_platform()    
    
    subprocess.call(shell_type, env=environment_snapshot)
    
    return None


@app.command(
    help="Command to obtain user's access token. Token will be printed out. Usable only when 'login_url' or 'login_credentials' was used for the authentication."
)
def get_access_token(
        exit_on_error: Annotated[bool, typer.Option(help="If True, program will exit() on error.")]=True
    ) -> None:

    environment_snapshot: dict = os.environ
    refresh_token: str = environment_snapshot.get("PY4LEXIS_TOKEN")

    if refresh_token is None:
        raise Exception("'PY4LEXIS_TOKEN' is not defined in environment variables!")

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    print(f"Access token: {session.get_access_token()}")

    return None


@app.command(
    help="Command to obtain user's refresh (offline) token. Token will be printed out. Usable only when 'login_url' or 'login_credentials' was used for the authentication."
)
def get_refresh_token(
        exit_on_error: Annotated[bool, typer.Option(help="If True, program will exit() on error.")]=True
    ) -> None:

    environment_snapshot: dict = os.environ
    refresh_token: str = environment_snapshot.get("PY4LEXIS_TOKEN")

    if refresh_token is None:
        raise Exception("'PY4LEXIS_TOKEN' is not defined in environment variables!")

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    print(f"Refresh token: {session.get_refresh_token()}")
    
    return None


@app.command(
    help="Command to obtain user's offline (refresh) token. Token will be printed out. Usable only when 'login_url' or 'login_credentials' was used for the authentication."
)
def get_offline_token(
        exit_on_error: Annotated[bool, typer.Option(help="If True, program will exit() on error.")]=True
    ) -> None:

    environment_snapshot: dict = os.environ
    refresh_token: str = environment_snapshot.get("PY4LEXIS_TOKEN")

    if refresh_token is None:
        raise Exception("'PY4LEXIS_TOKEN' is not defined in environment variables!")

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    print(f"Offline token: {session.get_offline_token()}")
    
    return None


@app.command(
    help="Logout from Lexis Session in CLI, e.g., command is used to clear the session (especially when [b]offline token[/b] is used)."
)
def logout(refresh_token: Annotated[Optional[str], typer.Option(help="Token which will be used for logout (clearing the session). By default 'PY4LEXIS_TOKEN' defined in environment variables is used." )]=None,
           exit_on_error: Annotated[bool, typer.Option(help="If True, program will exit() on error.")]=True) -> None:

    if refresh_token is None:
        environment_snapshot: dict = os.environ
        refresh_token: str = environment_snapshot.get("PY4LEXIS_TOKEN")

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    session.logout()

    os.environ.pop('PY4LEXIS_TOKEN', None)
    
    if _get_shell_for_platform() == "bash":
        os.kill(os.getppid(), signal.SIGHUP)
        
    sys.exit()    


if __name__ == "__main__":
    app()