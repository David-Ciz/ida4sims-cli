from logging import (
    Logger, 
    getLogger
)
from typing import Optional
from json import (
    dumps, 
    loads
)
import os

# Making ASCII table
# Source: https://stackoverflow.com/questions/5909873/how-can-i-pretty-print-ascii-tables-with-python
import typer
from pandas import DataFrame
from tabulate import tabulate
from typing_extensions import Annotated

from py4lexis.core.exceptions import Py4LexisAirflowException
from py4lexis.session import LexisSessionOffline
from py4lexis.workflows.airflow import Airflow
from py4lexis.cli.typings import Status


app = typer.Typer(name="airflow",
                  help="Holds commands to manage LEXIS Airflow instance. Type '[b]python -m py4lexis.cli airflow --help[/b]' to see list of available commands.",
                  rich_markup_mode="rich")


logger: Logger = getLogger(__name__)


@app.command()
def get_workflows_list(filter_workflow_id: Annotated[
                            Optional[str],
                            typer.Option(help="To filter ASCII table by workflow ID.")
                       ]=None,
                       filter_project: Annotated[
                           Optional[str],
                           typer.Option(help="To filter content by project's short name.")
                       ]=None,
                       filter_is_subdag: Annotated[ 
                           Optional[bool], 
                           typer.Option(help="To filter ASCII table by 'Is Subdag'")
                       ]=None,
                       filter_is_active: Annotated[ 
                           Optional[bool], 
                           typer.Option(help="To filter ASCII table by 'Is Active'")
                       ]=None,
                       filter_is_paused: Annotated[ 
                           Optional[bool], 
                           typer.Option(help="To filter ASCII table by 'Is Paused'")
                       ]=None,
                       refresh_token: Annotated[
                           Optional[str],
                           typer.Option(help="Refresh (offline) token used for authentication. By default environemnt variable 'PY4LEXIS_TOKEN' is used.")
                       ]=None,
                       exit_on_error: Annotated[
                           bool,
                           typer.Option(help="If True, program will exit() on error.")
                       ]=True
                      ) -> None:
    """
    Prints the table of existing workflows (DAGs) with short info.

    [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]
    
    [bold yellow]Further description:[/bold yellow]
    
    [b yellow]*[/b yellow] Content of the ASCII table can be filtered using the following options: --filter-workflow-id, --filter-project, --(no-)filter-is-subdag, --(no-)filter-is-active, --(no-)filter-is-paused.

    [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]

    [bold red]Examples of usage[/bold red]:

    [b]Get whole list: [/b]
        [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflows-list

    [b]Get whole list and filter it by workflow ID: [/b]
        [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflows-list --filter-workflow-id lexis_som

    [b]Get whole list and filter it by NOT active state: [/b]
        [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflows-list --no-filter-is-active
    """

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    airflow: Airflow = Airflow(session=session, 
                               suppress_print=False,
                               exit_on_error=exit_on_error)

    content = airflow.get_workflows_list(content_as_pandas=True,
                                         filter_project=filter_project)
    
    try:
        print(f"Formatting pandas DataFrame into ASCII table...")
        
        cols: list[str] = ["WorkflowID (dag_id)", "Description", "Tags", "Is subdag", "Is active", "Is paused"]
        workflows_table: DataFrame = DataFrame(columns=cols)
        workflows_table["WorkflowID (dag_id)"] = content["dag_id"]
        workflows_table["Description"] = content["description"]
        workflows_table["Tags"] = content["tags"]
        workflows_table["Is subdag"] = content["is_subdag"]
        workflows_table["Is active"] = content["is_active"]
        workflows_table["Is paused"] = content["is_paused"]

        if filter_workflow_id is not None:
            workflows_table = workflows_table[workflows_table["WorkflowID (dag_id)"] == filter_workflow_id]

        if filter_is_subdag is not None:
            workflows_table = workflows_table[workflows_table["Is subdag"] == filter_is_subdag]

        if filter_is_active is not None:
            workflows_table = workflows_table[workflows_table["Is active"] == filter_is_active]

        if filter_is_paused is not None:
            workflows_table = workflows_table[workflows_table["Is paused"] == filter_is_paused]
        
        print(tabulate(workflows_table.values.tolist(), cols, tablefmt="grid"))

    except KeyError as kerr:
        raise Py4LexisAirflowException(f"Wrong or missing key '{kerr}' in response content as DataFrame!!!")
    
    return None


@app.command()
def get_workflow_info(workflow_id: Annotated[
                         str, 
                         typer.Argument(help="Workflow ID (dag_id) of the existing workflow.")
                      ],
                      refresh_token: Annotated[
                         Optional[str],
                         typer.Option(help="Refresh (offline) token used for authentication. By default environemnt variable 'PY4LEXIS_TOKEN' is used.")
                      ]=None,
                      exit_on_error: Annotated[
                           bool,
                           typer.Option(help="If True, program will exit() on error.")
                       ]=True) -> None:
    """
        Prints info of existing workflow (DAG) selected by its workflow ID (dag_id).
        
        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]
    
        [bold yellow]Further description:[/bold yellow]
        
        [b yellow]*[/b yellow] Content will be printed as JSON.

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]

        [bold red]Examples of usage[/bold red]:

        [b]Get workflow info: [/b]
            [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflow-info lexis_som
    """

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    airflow: Airflow = Airflow(session=session, 
                               suppress_print=False,
                               exit_on_error=exit_on_error)

    content: list[dict] = airflow.get_workflow_info(workflow_id)

    print(dumps(content, indent=4))

    return None
    

@app.command()
def get_workflow_details(workflow_id: Annotated[
                            str, 
                            typer.Argument(help="Workflow ID (dag_id) of the existing workflow.")
                         ],
                         refresh_token: Annotated[
                            Optional[str],
                            typer.Option(help="Refresh (offline) token used for authentication. By default environemnt variable 'PY4LEXIS_TOKEN' is used.")
                         ]=None,
                         exit_on_error: Annotated[
                           bool,
                           typer.Option(help="If True, program will exit() on error.")
                         ]=True) -> None:
    """
        Prints details of existing workflow (DAG) selected by its workflow ID (dag_id).

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]
    
        [bold yellow]Further description:[/bold yellow]
        
        [b yellow]*[/b yellow] Content will be printed as JSON.

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]

        [bold red]Examples of usage[/bold red]:

        [b]Get workflow info details: [/b]
            [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflow-details lexis_som
    """
    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    airflow: Airflow = Airflow(session=session, 
                               suppress_print=False,
                               exit_on_error=exit_on_error)
    
    content: list[dict] = airflow.get_workflow_details(workflow_id)

    print(dumps(content, indent=4))
    
    return None


@app.command()
def get_workflow_params(workflow_id: Annotated[
                            str, 
                            typer.Argument(help="Workflow ID (dag_id) of the existing workflow.")
                        ],
                        refresh_token: Annotated[
                            Optional[str],
                            typer.Option(help="Refresh (offline) token used for authentication. By default environemnt variable 'PY4LEXIS_TOKEN' is used.")
                        ]=None,
                        exit_on_error: Annotated[
                           bool,
                           typer.Option(help="If True, program will exit() on error.")
                        ]=True) -> None:
    """
        Gets params of existing workflow (DAG) selected by its workflow ID (dag_id), prints them into console/terminal and save as JSON file to CWD named as workflow ID.

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]
    
        [bold yellow]Further description:[/bold yellow]
        
        [b yellow]*[/b yellow] Workflow parameters JSON will be saved into a file ' ~/.py4lexis/wrfs/WORKFLOW_ID.json'.

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]

        [bold red]Examples of usage[/bold red]:

        [b]Get workflow params: [/b]
            [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflow-params lexis_som
    """
    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    airflow: Airflow = Airflow(session=session, 
                               suppress_print=False,
                               exit_on_error=exit_on_error)
    
    wf_default_parameters: dict = airflow.get_workflow_params(workflow_id)

    print(dumps(wf_default_parameters, indent=4))

    if not os.path.exists(f"{os.path.expanduser('~')}/.py4lexis/wrfs"):
        os.mkdir(f"{os.path.expanduser('~')}/.py4lexis/wrfs")
        
    with open(f"{os.path.expanduser('~')}/.py4lexis/wrfs/{workflow_id}.json", "wb") as file:
        file.write(dumps(wf_default_parameters).encode("utf-8"))
        file.close()        
    
    print(f"Workflow params successfully saved to: ~/.py4lexis/wrfs/{workflow_id}.json")

    return None


@app.command()
def execute_workflow(workflow_id: Annotated[
                        str, 
                        typer.Argument(help="Workflow ID (dag_id) of the existing workflow.")
                     ],
                     workflow_run_id: Annotated[
                         Optional[str],
                         typer.Option(help="Workflow run id (dag_run_id).")
                     ]=None,
                     suppress_print: Annotated[
                         bool,
                         typer.Option(help="If prints have to be suppressed or not. By default 'False'.")
                     ]=False,
                     refresh_token: Annotated[
                       Optional[str],
                       typer.Option(help="Refresh (offline) token used for authentication. By default environemnt variable 'PY4LEXIS_TOKEN' is used.")
                     ]=None,
                     exit_on_error: Annotated[
                           bool,
                           typer.Option(help="If True, program will exit() on error.")
                     ]=True
                    ) -> None:
    """
        Execute manually an existing workflow (DAG) which is selected by its workflow ID (dag_id) and prints the result.

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]
    
        [bold yellow]Further description:[/bold yellow]
        
        [b yellow]*[/b yellow] Workflow parameters will be loaded from JSON (from a file '~/.py4lexis/wrfs/WORKFLOW_ID.json' saved by get-workflow-params). If no file is found, Exception will be raised.
        
        [b yellow]*[/b yellow] Workflow run ID will be set automatically as 'py4lexis_exec_'+datetime.now().isoformat()+'_'+str(round(random()*100))' if workflow_run_id='None'.

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]

        [bold red]Examples of usage[/bold red]:

        [b]Execute workflow: [/b]
            [b yellow]>[/b yellow] python -m py4lexis.cli.airflow execute-workflow lexis_som
    """

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    airflow: Airflow = Airflow(session=session, 
                               suppress_print=suppress_print,
                               exit_on_error=exit_on_error)

    try:
        file = open(f"{os.path.expanduser('~')}/.py4lexis/wrfs/{workflow_id}.json", "rb")
        json_params: bytes = file.read()
        workflow_parameters: dict = loads(json_params.decode("utf-8"))
    
    except OSError:
        raise Py4LexisAirflowException(f"No file ~/.py4lexis/wrfs/{workflow_id}.json was found in CWD. Cannot load workflow params.")

    content: list[dict] = airflow.execute_workflow(workflow_id, workflow_parameters, workflow_run_id)

    print(dumps(content, indent=4))

    return None
        

@app.command()
def get_workflow_states(workflow_id: Annotated[
                            str, 
                            typer.Argument(help="Workflow ID (dag_id) of the existing workflow.")
                        ],
                        filter_run_id: Annotated[
                            Optional[str],
                            typer.Option(help="To filter workflow states by workflow run ID.")
                        ]=None, 
                        filter_state: Annotated[
                            Optional[Status],
                            typer.Option(help="To filter workflow states by their current state.")
                        ]=None,
                        refresh_token: Annotated[
                            Optional[str],
                            typer.Option(help="Refresh (offline) token used for authentication. By default environemnt variable 'PY4LEXIS_TOKEN' is used.")
                        ]=None,
                        exit_on_error: Annotated[
                           bool,
                           typer.Option(help="If True, program will exit() on error.")
                        ]=True) -> None:
    """
        Prints run states of existing workflow (DAG) selected by its workflow ID (dag_id).

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]
    
        [bold yellow]Further description:[/bold yellow]
        
        [b yellow]*[/b yellow] It is possible to filter records by: --filter-run-id, --filter-state.

        [bold blue]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[/bold blue]

        [bold red]Examples of usage[/bold red]:

        [b]Get all states: [/b]
            [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflow-states lexis_som

        [b]Get all states filtered by 'success' state: [/b]
            [b yellow]>[/b yellow] python -m py4lexis.cli.airflow get-workflow-states lexis_som --filter-state success
    """

    session: LexisSessionOffline = LexisSessionOffline(in_cli=True,
                                                       refresh_token=refresh_token,
                                                       exit_on_error=exit_on_error)
    airflow: Airflow = Airflow(session=session, 
                               suppress_print=False,
                               exit_on_error=exit_on_error)

    content: DataFrame = airflow.get_workflow_states(workflow_id, content_as_pandas=True)
       
    cols: list[str] = ["WorkflowRunID", "ExecutionDate", "State"]
    workflows_table: DataFrame = DataFrame(columns=cols)
    workflows_table["WorkflowRunID"] = content["workflow_run_id"]
    workflows_table["ExecutionDate"] = content["execution_date"]
    workflows_table["State"] = content["state"]

    if filter_run_id is not None:
        workflows_table = workflows_table[workflows_table["WorkflowRunID"] == filter_run_id]
    
    if filter_state is not None:
        workflows_table = workflows_table[workflows_table["State"] == filter_state.value]

    print(tabulate(workflows_table.values.tolist(), cols, tablefmt="grid"))
    
    return None

   
if __name__ == "__main__":
    app()