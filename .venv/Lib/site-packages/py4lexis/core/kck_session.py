from time import sleep
import webbrowser
from base64 import b64decode

from requests import (
    Response, 
    post
)
from keycloak import (
    KeycloakOpenID, 
    KeycloakPostError
)

import shutil

from py4lexis.core.exceptions import Py4LexisAuthException
from py4lexis.core.helper import (
    Clr, 
    _aai_pth, 
    _cl, 
    _cl_cli, 
    _cl_s, 
    _sc, 
    _sc_off,
    _dvc_cd, 
    _hs, 
    _rs
)
from py4lexis.models.tokens import Tokens


__all__ = ["kck_oi"]


class kck_oi():

    def __init__(self, 
                 in_cli: bool,
                 auth_url: str | None=None,
                 realm: str | None=None,
                 client_id: str | None=None,
                 client_secret: str | None=None,
                 offline_access: bool=False) -> None:
        self._Clr: Clr = Clr() 
        self._cl: str = client_id
        self._cl_s: str = client_secret

        if self._cl is None:
            if in_cli:
                self._cl = self._Clr.yhbrr(_cl_cli)
                self._cl_s = self._Clr.yhbrr(_cl_s)
            else:
                self._cl = self._Clr.yhbrr(_cl)
                self._cl_s = self._Clr.yhbrr(_cl_s)

        url: str = self._Clr.yhbrr(_aai_pth) + b64decode(b"L2F1dGgv").decode("utf-8") if auth_url is None else auth_url
        realm_name: str = self._Clr.get("AR") if realm is None else realm

        self._offline_access = offline_access

        self._oid = KeycloakOpenID(url, 
                                   realm_name, 
                                   self._cl, 
                                   client_secret_key=self._cl_s)
        
    def _get_username(self, tokens: dict[str, str | int]) -> str:
        if not "access_token" in tokens.keys():
            raise Py4LexisAuthException("'access_token' is not defined in response dict")

        if not isinstance(tokens["access_token"], str):
            raise Py4LexisAuthException("Token in '_get_username' is not a string")
        
        token: str = tokens["access_token"]
        _Clr: Clr = Clr()
        userinfo: dict[str, str] = self._oid.decode_token(token=token,  
                                                          algs=[_Clr.yhbrr(_hs), _Clr.yhbrr(_rs)])
        
        if not "preferred_username" in userinfo:
            raise Py4LexisAuthException("'preferred_username' is not in jwt token")
        
        return userinfo["preferred_username"]


    def rfsh_token(self, token: str) -> Tokens:
        try:
            rcv_tokens: dict[str, str | int] = self._oid.refresh_token(token)
            rcv_tokens.update({"username": self._get_username(rcv_tokens)})
            
            tokens: Tokens = Tokens.model_validate(rcv_tokens)

            return tokens
        
        except KeycloakPostError as exc:
            raise Py4LexisAuthException(f"{exc.error_message}")
        

    def logout(self, token: str) -> dict:
        try:
            response: dict[str, str | int] = self._oid.logout(token)

            return response
        
        except KeycloakPostError as exc:
            raise Py4LexisAuthException(f"{exc.error_message}")
    
    
    def login(self) -> Tokens:
        body: dict[str, str] = {
            "client_id":self._cl,
            "client_secret": self._cl_s,
            "scope": self._Clr.yhbrr(_sc) if not self._offline_access else self._Clr.yhbrr(_sc) + " " + self._Clr.yhbrr(_sc_off)
        }

        headers: dict[str, str] = {
            "ContentType": b64decode(b'YXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVk').decode("utf-8")
        }

        response: Response = post(self._Clr.yhbrr(_aai_pth) + 
                                  b64decode(b"L2F1dGgvcmVhbG1zLw==").decode("utf-8") + 
                                  self._Clr.get("AR") + 
                                  b64decode(b"L3Byb3RvY29sL29wZW5pZC1jb25uZWN0L2F1dGgvZGV2aWNl").decode("utf-8"),
                                  data=body, 
                                  headers=headers)
        content: dict[str, str | int] = response.json()
        
        print(f"Open provided url in your browser, please: {content['verification_uri_complete']}")
        webbrowser.open(content['verification_uri_complete'])

        body: dict[str, str] = {
            "device_code": content["device_code"],
            "client_id": self._cl,
            "client_secret": self._cl_s,
            "grant_type": self._Clr.yhbrr(_dvc_cd)
        }

        is_auth: bool = False
        counter: int = 0
        tokens: Tokens | None = None
        console_width: int = shutil.get_terminal_size().columns
        white_space: str = " " * console_width
        while not is_auth and counter < 120:
            if counter % 3 == 0:
                print(f"{white_space}\rCheck if user is logged in: Pending.", end="\r")
            elif counter % 3 == 1:
                print(f"{white_space}\rCheck if user is logged in: Pending..", end="\r")
            else:
                print(f"{white_space}\rCheck if user is logged in: Pending...", end="\r")

            if counter % 3 == 0:
                response: Response = post(self._Clr.yhbrr(_aai_pth) + 
                                        b64decode(b"L2F1dGgvcmVhbG1zLw==").decode("utf-8") + 
                                        self._Clr.get("AR") + 
                                        b64decode(b"L3Byb3RvY29sL29wZW5pZC1jb25uZWN0L3Rva2Vu").decode("utf-8"), 
                                        data=body, 
                                        headers=headers)
                content: dict[str, str | int] = response.json()

            if response.status_code == 200:
                is_auth = True
                continue                

            sleep(1)
            counter += 1

        print("")
        if not is_auth:
            log_msg: str = f"Check if user is logged in: FAILED! (timeout)"
            print(log_msg)
            raise Py4LexisAuthException(log_msg)
        
        print(f"Check if user is logged in: OK!")

        content.update({"username": self._get_username(content)})

        tokens: Tokens = Tokens.model_validate(content)

        return tokens
    
    
    def login_password(self, username: str, password: str) -> Tokens:
        rcv_tokens: dict[str, str | int] = self._oid.token(username=username,
                                                           password=password,
                                                           grant_type="password",
                                                           scope=self._Clr.yhbrr(_sc) if not self._offline_access else self._Clr.yhbrr(_sc) + " " + self._Clr.yhbrr(_sc_off))
        
        rcv_tokens.update({"username": self._get_username(rcv_tokens)})
        tokens: Tokens = Tokens.model_validate(rcv_tokens)

        return tokens
