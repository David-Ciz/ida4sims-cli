
from __future__ import annotations

from logging import (
    Logger, 
    getLogger
)
from typing import (
    Generator, 
    Literal
)
import hashlib
import shutil

from pandas import DataFrame

from py4lexis.models.directory_tree import TreeDirectoryObject
from py4lexis.core.directory_tree import DirectoryTree
from py4lexis.core.exceptions import Py4LexisException
from py4lexis.session import LexisSession


logger: Logger = getLogger(__name__)


class ProgressBar(object):
    def __init__(self,
                 total: int,
                 prefix: str="", 
                 suffix: str="", 
                 decimals: int=1, 
                 length: int=100, 
                 fill: str="█", 
                 printEnd: str="\r") -> None:
        self.iter_i: int = 0
        self.total: int = total
        self.prefix: str = prefix
        self.suffix: str = suffix
        self.decimals: int = decimals
        self.length: int = length
        self.fill: str = fill
        self.printEnd: str = printEnd

    def print_progress(self,
                      suffix: str | None=None):
        
        if suffix is not None:
            self.suffix = suffix
        
        printProgressBar(iteration=self.iter_i,
                         total=self.total,
                         prefix=self.prefix,
                         suffix=self.suffix,
                         decimals=self.decimals,
                         length=self.length,
                         fill=self.fill,
                         printEnd=self.printEnd)
        
        self.iter_i += 1
        

def printProgressBar(iteration: int, 
                     total: int, 
                     prefix: str="", 
                     suffix: str="", 
                     decimals: int=1, 
                     length: int=100, 
                     fill: str="█", 
                     printEnd: str="\r") -> None:
    """
        Call in a loop to create terminal progress bar. Source: https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters

        Parameters
        ----------
        iteration : int
            Current iteration.
        total : int
            Total iterations.
        prefix : str | None
            Prefix string.
        suffix : str | None
            Suffix string.
        decimals : int | None
            Positive number of decimals in percent complete.
        length : int | None
            Character length of bar.
        fill : str | None
            Bar fill character.
        printEnd : str | None
            End character (e.g. "\r", "\r\n").

        Return
        ------
        None    
    """
    if total == 0:
        total = 1 
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + "-" * (length - filledLength)

    # to clear previous line
    console_width: int = shutil.get_terminal_size().columns
    white_space = " " * console_width

    prog_bar: str = f"{prefix} |{bar}| {percent}%"

    # to trim suffix
    overline: int = len(f"{prog_bar} {suffix}") - console_width

    if overline > 0:
        tmp_suffix: str = ""

        if suffix[0] == "(" or suffix[0] == "[" or suffix[0] == "{":
            tmp_suffix += suffix[0]

        overline += 3
        suffix = tmp_suffix + "..." + suffix[overline+1:]

    print(f"{white_space}\r{prog_bar} {suffix}", end=printEnd)  # clear and print

    # Print New Line on Complete
    if iteration == total:
        print()


def convert_get_datasets_status_to_pandas(content: list[dict], 
                                          suppress_print: bool=False) -> DataFrame:
    """
        Convert HTTP response content of GET datasets status from JSON format to pandas DataFrame.
        
        Parameters
        ----------
        content : list[str]
            HTTP response content.
        suppress_print : bool | None
            If True all prints are suppressed.

        Return
        ------
        DataFrame
            Status information table of all datasets.
    """

    item_list: list[str] = ["project", "status", "result",
                            "type", "request_id", "created_at"]

    cols: list[str] = []
    for item in item_list:
        tmp_item: str = "".join(tmp.capitalize() for tmp in item.split("_"))

        if "Id" in tmp_item:
            tmp_item = tmp_item[:-2] + "ID"
        cols.append(tmp_item)
    
    datasets_table: DataFrame = DataFrame(columns=cols)

    try:
        log_msg: str = f"Converting HTTP content from JSON to pandas Dataframe..."
        logger.info(log_msg)
        if not suppress_print:
            print(log_msg)

        for i, content_i in enumerate(content['requests']):
            row_i: list[str] = []
            for item in item_list:
                if item in content_i:
                    row_i.append(content_i[item])
                else:
                    tmp_item: str = "".join(tmp.capitalize() for tmp in item.split("_"))
                    row_i.append(f"UNKNONW {tmp_item}")

            datasets_table.loc[i] = row_i
        
    except Exception as err:
        raise Py4LexisException(f"Unexpected error while converting datasets' upload status from content to pandas DataFrame. Exception: {str(err)}")

    return datasets_table
 

def convert_get_all_datasets_to_pandas(content: list[dict],
                                       suppress_print: bool=False) -> DataFrame:
    """
        Convert HTTP response content of GET all datasets from JSON format to pandas DataFrame.
        
        Parameters
        ----------
        content : list[str]
            HTTP response content.
        suppress_print : bool | None
            If True all prints are suppressed.

        Return
        ------
        DataFrame
            Information table of all datasets.
    """

    datacite_items: list[str] = ["publisher", "types", "publicationYear"]
    
    lexis_items: list[str] = ["internalID", "access", "project", "zone", "title", "creationDate"]

    cols: list[str] = []
    for item in lexis_items:
        cols.append(item[0].upper() + item[1:])
    for item in datacite_items:
        cols.append(item[0].upper() + item[1:])
    
    datasets_table: DataFrame = DataFrame(columns=cols)

    try:
        log_msg: str = f"Converting HTTP content from JSON to pandas Dataframe..."
        logger.info(log_msg)
        if not suppress_print:
            print(log_msg)

        for i, content_i in enumerate(content):
            row_i: list[str] = []

            for item in lexis_items:
                if item == 'project':
                    item = 'project_shortname'
                if item in content_i["lexis"]:
                    if isinstance(content_i["lexis"][item], list) and len(content_i["lexis"][item]) > 0:
                        row_i.append(content_i["lexis"][item][0])
                    else:
                        row_i.append(content_i["lexis"][item])
                else:
                    row_i.append(f"UKNOWN {item.title()}")
            
            if "datacite" in content_i.keys():
                for item in datacite_items:
                    if item in content_i["datacite"]:
                        if isinstance(content_i["datacite"][item], list) and len(content_i["datacite"][item]) > 0:
                            row_i.append(content_i["datacite"][item][0])
                        else:    
                            row_i.append(content_i["datacite"][item])
                    else:
                        row_i.append(f"UKNOWN {item.title()}")
            else:
                for item in datacite_items:
                    row_i.append("UKNOWN")

            datasets_table.loc[i] = row_i

    except Exception as err:
        raise Py4LexisException(f"Unexpected error while converting information about datasets from content to pandas DataFrame. Exception: {str(err)}")
        
    return datasets_table
      

def convert_dir_tree_to_pandas(content: list[dict],
                               suppress_print: bool=False) -> DataFrame:
    """
        Convert HTTP response content of GET list of files in dataset from JSON format to pandas DataFrame.
        
        Parameters
        ----------
        session : LexisSession
            Current Lexis Session.
        content : list[str]
            HTTP response content.
        suppress_print : bool | None
            If True all prints are suppressed.

        Return
        ------
        DataFrame
            List of files in dataset formated into DataFrame table.
    """

    cols: list[str] = ["Dir/File-name", "Path", "Type", "Size", "CreateTime", "Checksum"]
    
    datasets_table: DataFrame = DataFrame(columns=cols)

    try:
        log_msg: str = f"Converting HTTP content from JSON to pandas Dataframe..."
        logger.info(log_msg)
        if not suppress_print:
            print(log_msg)        

        tree_content: TreeDirectoryObject = TreeDirectoryObject(content)
        tree_items: Generator[DirectoryTree, None, None] = DirectoryTree.make_tree(tree_content)
        row_id: int = 0
        for item in tree_items:
            row: list[str | int] | None = item.to_dataframe_row()
            if row is not None:
                datasets_table.loc[row_id] = row
                row_id = row_id + 1
        
    except Exception as err:
        raise Py4LexisException(f"Unexpected error while converting directory tree from content to pandas DataFrame. Exception: {str(err)}")
        
    return datasets_table  
    

def convert_list_of_dicts_to_pandas(session: LexisSession, 
                                    content: list[dict] | dict,                                      
                                    suppress_print: bool=False) -> DataFrame:
    """
        Convert from list of general objects to pandas DataFrame.
        
        Parameters
        ----------
        session : LexisSession
            Current Lexis Session.
        content : list[str]
            HTTP response content.
        suppress_print : bool | None
            If True all prints are suppressed.

        Return
        ------
        DataFrame
            List of files in dataset formated into DataFrame table. None is returned when some errors have occured.
    """

    if len(content) > 0:
        cols: list[str] = list(content[0].keys())

        if "internalID" in cols:
            idx: int = cols.index("internalID")
            cols[idx] = "dataset_id"

        if "absolutePath" in cols:
            idx: int = cols.index("absolutePath")
            cols[idx] = "absolute_path"   

        if "lastModifiedDate" in cols:
            idx: int = cols.index("lastModifiedDate")
            cols[idx] = "last_modified_date"  

        if "creationDate" in cols:
            idx: int = cols.index("creationDate")
            cols[idx] = "creation_date"    

        if "additionalMetadata" in cols:
            idx: int = cols.index("additionalMetadata")
            cols[idx] = "additional_metadata"

        datasets_table: DataFrame = DataFrame(columns=cols)

        try:
            session._logging.info(f"Converting HTTP content from JSON to pandas Dataframe -- PROGRESS")

            if not suppress_print:
                print(f"Converting HTTP content from JSON to pandas Dataframe...")
            
            for i, item in enumerate(content):

                for col in cols:
                    if col not in list(item.keys()):
                        datasets_table.at[i, col] = None
                    else:    
                        datasets_table.at[i, col] = item[col]
            
        except Exception as err:
            raise Py4LexisException(f"Unexpected error while converting directory tree from content to pandas DataFrame. Exception: {err}")
    else:
        datasets_table: DataFrame = DataFrame()
        
    return datasets_table    
    

def assemble_dataset_path(access: Literal["user", "project", "public"], 
                          project: str, 
                          dataset_id: str | None=None, 
                          username: str | None=None) -> str:
    """
        Returns a path for an existing dataset as the combination of access, project, internalID and username.

        Parameters:
        -----------
        session: LexisSession
            Current Lexis session.
        access : Literal["user", "project", "public"]
            Access mode of the project (user, project, public)
        project : str
            Project's short name.
        dataset_id : str | None
            Dataset ID as UUID.
        username : str | None
            The iRODS username. Needed when user access is defined

        Returns:
        --------
        str | None
            Staging dataset path.

    """

    path: str = ""
    if access == "user":
        if username is None:
            raise Py4LexisException("Username is None!!!")
        
        path = f"user/{__targetProjectHash(project)}/{username}"
    elif access == "project":
        path = f"project/{__targetProjectHash(project)}"
    elif access == "public":
        path = f"public/{__targetProjectHash(project)}"
    else:
        return "No_Dataset_Specified"
    
    if dataset_id is not None:
        path = f"{path}/{dataset_id}"
    
    return path


def __targetProjectHash(project: str) -> str:
    """
        Hashes a project which allows the mapping of projects to paths in iRODS.

        Parameters:
        -----------
        project : str
            Project's short name.

        Returns:
        --------
        str
            The project hash.

    """
    
    tmpHash: str = hashlib.md5(project.encode("utf8")).hexdigest()
    return "proj" + tmpHash