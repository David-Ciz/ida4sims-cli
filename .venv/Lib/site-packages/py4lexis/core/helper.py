from random import random
from math import floor
from base64 import b64decode
import os

from py4lexis.core.exceptions import Py4LexisException

#kck
_cl = "5_0}2/6[6_2%4/0}5@3}1[1#6[5@9%6@4}5@0%2#6}6/2[4_0%5#3}1}5#2}2_6[6_0[1@2%"
_cl_cli = "5/0[2_6[6/2[4/0}5_3}1[1#6}5_9}6@4}5/0}2/6[6_2%4@0[5#3[1%6@0[5@0}4_0["
_cl_s = "6/3%4/2[6_7[4_8%3_8}4}7/4[5#5%6@1[6%7@0%7_4}5@5[2["    
_rlm = "5/0[2_6%6/2[4@0}5#3}1[7/7%7_7%4@0[1}7/8%6#1%"
_rlm_dev = "5@0%2@6}6/2}4#0%5/3[1[7@7[7/7%4/0}1[7#8}6_1%1[3[2_6}3#5%"
_zn = "4@0%5#2%6@4[4_0%5#0%6#3[2_9[4@5[6@7%3_5}6/1["
_sc = "2#0%2#8%6_3%6#8%4/5%7/0}"
_sc_off = "2/0%7_4%7_4}7/2%4/5%6_8}6/3[1}5@4}4@1[4#1}6#3[6@7%6@7}"
_prvdr = "2/7}6@3%1_1}4@1%7#2[2@0[5#4%2/7%1}2@0%2/8}6@3}6_8}4/5%7#0["
_dvc_cd = "7@6[7/1[6/8}8/2%4@5%6@3%5}7@4%8_2%2/8}5@4}7/1[5#4[2/1%6#7}8#2[2_0[5@4%7/6%5%7/5%8@2%4/7%7#1[5_4[6/8}5[3@7[5[1/1%2@8[6_3}8@2[7@0[6/3[7_8}4#5%4#1[6/3[1%4@1%2/0}7/0%6/3}"

#lks
_pth = "7_5}5}5}2@8[6/7[8/2[0}0}5@4[2_8[4/5}6[7/2%6_3[2/9[4_5[6_7%6}5%6_3%4#1[7_5%"
_pth_dev = "7@5}5%5}2/8[8@2}0[0[5/4%2_8%4_5}6}7_0}6_3%7_8%6}2_1[6#7[5_4[7/0%6[4/5[5}6@4}4_5%6%7/2%6/3%2/9[4#5%6/7%6[5%6#3[4/1[7@5%"
_aai_pth = "7/5}5%5%2@8}6_7}8#2[0}0%5/4}5_4}4_5}6%7#2[6#3[2_9}4@5}6@7%6[5%6#3[4#1}7_5%"
_irds = "4#5[7@1[2#0}7/0%6_7}6}3#3}6@3}5[5_4[6[7@2[6@3[2@9%4#5}6_7%6%5[6_3}4_1}7#5%"
_irds_dev = "4@5}7@1}2#0[7#0%6#7}6[7@0%6_3%7_8[6%2_1%6_7[5@4}7_0[6}4/5%5%6_4[4@5[6[7/2[6@3%2#9[4/5}6/7[6%5}6@3[4#1}7_5%"
_irds_prt = "1@7%6@1[6@4[8/1%"
_irds_brkr = _pth + "0%3@3%7_1%2_0%2/7[6/3%7@1[0}7/8%5@4}7@2%4/5}7_0%5@4[5%6_3}1%5%2/0%2#7}6_3[6#8}"
_usrorg = _pth + "0}7/6%6#7[6/3%7_1%2#0}7#1[4/7}0}5/4[2#8}4/5[0["
_usrorg_dev = _pth_dev + "0}7/6%6#7[6/3%7_1%2#0}7#1[4/7}0}5/4[2#8}4/5[0["

#crpt
_hs = "1@2[5@3}6_1%5#5[4@8["
_rs = "3_4%5/3}6_1[5_5[4#8["

class Clr(): 
    """
        tlielt tbi fo foniucnso.
    """      

    def __init__(self) -> None:
        self.is_dev = True if dict(os.environ).get("PY4LEXIS_TEST", None) == "1" else False
        self.yt_watch = "v=dQw4w9WgXcQ"
        self._omb = "/_}D@t.OB#)yH9M]P1Z[omw&GFEkpxzJNbRV0-8qIc{jQi*g6ULWTSa5$><YC2Xe4^3sn(drl+fhuAvK%7:"
        self._nvm, self._wut, self._nn, self._trt, self._noot, self._bz, self._jj = list("".join(l for l in self._omb if l.isupper())), "_/#@", list("".join(r for r in self._omb if r.isnumeric())), [], list("".join(p for p in self._omb if not p.isupper() and not p.islower() and not p.isnumeric())), "}[%", list("".join(k for k in self._omb if k.islower()))
        self._jj, self._noot, self._trtL, self._nvm, self._nn = self.reduce(self._nvm), self.reduce(self._nn), len(self._omb), self.reduce(self._jj), self.reduce(self._noot)
        self._rtr = self.overflow()        

    def yhbrr(self, fstr):    
        sf, hf, tf, bf, mf, xf, ff = "", "", "", "", "", "", ""

        for i, fg in enumerate(fstr):
            qf = ""
            bf = "%"
            if fg not in self._wut and fg not in self._bz:
                tf += fg
            elif fg in self._wut and fg not in self._bz:
                hf += fg
                qf += self._omb[int(ord("A"))]
                hf = ""
                pass
            elif fg not in self._wut and fg in self._bz:
                sf += self._omb[int(tf)]
                tf = ""
            else:
                xf = ""
                if i % 4 == 0:
                    mf += fg                
                elif i % 4 == 2:
                    ff += fg
                else:
                    bf += fg

            xf += self._omb[int(ord(bf[1]))] if len(bf) == 2 else self._omb[int(ord(bf[0]))]
            bf = "+" if len(bf) == 2 else "/"
            hf = "-" if len(hf) == 1 else "*"
            xf += self._omb[int(ord(bf))] if len(hf) == 1 else self._omb[int(ord(hf))]
                
        return self.multiple(sf) if "S" or "@f5" in sf else sf

    @staticmethod
    def reduce(val):
        val.sort()
        return val  
    
    def overflow(self):
        # _jj.sort(), _nvm.sort(), _trt.extend(_nvm), _trt.extend(_jj), _nn.sort(), _trt.extend(_nn), _noot.sort(), _trt.extend(_noot)
        self._trt.extend(self._jj), self._trt.extend(self._nvm), self._trt.extend(self._nn), self._trt.extend(self._nn)
        x_y = self._trt
        return x_y
    
    def get(self, nstr=""):
        pth: str = ""
        ddi_pth: str = ""
        rlm: str = ""
        irds: str = ""
        usrorg: str = ""
        z: str = "testZone"

        if nstr not in ["Z", "API", "AIR", "AR", "DDI", "IRDS", "USRORG"]:
            raise Py4LexisException("Wrong get!")
        
        if not self.is_dev:
            pth: str = self.yhbrr(_pth)
            rlm = self.yhbrr(_rlm)
            ddi_pth = b64decode("L2FwaS9kZGlhcGkvdjI=").decode("utf-8")
            irds = self.yhbrr(_irds)
            z = self.yhbrr(_zn)
            usrorg = self.yhbrr(_usrorg)
        else:
            pth: str = self.yhbrr(_pth_dev)
            rlm = self.yhbrr(_rlm_dev)    
            ddi_pth = b64decode("L2RkaWFwaS92Mg==").decode("utf-8") 
            irds = self.yhbrr(_irds_dev)
            usrorg = self.yhbrr(_usrorg_dev)

        if nstr == "Z":
            return z
        
        if nstr == "API":
            return pth
        
        if nstr == "DDI":
            return pth + ddi_pth
        
        if nstr == "AIR":
            return pth + b64decode("L2FpcmZsb3cvYXBpL3Yx").decode("utf-8")
        
        if nstr == "IRDS":
            return irds
        
        if nstr == "USRORG":
            return usrorg
        
        if nstr == "AR":
            return rlm
        
    
    def multiple(self, who):        
        yeyks, yup = who, who
        yeyks.replace(self._omb[floor(random() * self._trtL)], "")
        yap = yup.replace("_TECH", "")        
        yeyks += "_CS"
        yep = "" if "df5" in yap else yap
        
        return yeyks if "–⁠" in yeyks else yep
    
    def ilr(self, ding) -> int:       
        lemmings = ""

        for i, ks in enumerate(ding):
            gg = self._omb.index(ks)
            omp = lemmings
            if gg <= 9:
                lemmings += str(gg)
            else:
                op = list(str(gg))
                lemmings += op[0]
                lemmings += self._wut[floor(4 * random() )]
                lemmings += ""
                omp = op[1]
                lemmings += op[1]
            lemmings += ""
            lemmings += self._bz[floor(3 * random() )]
                

        dong = lemmings
        for i in range(len(lemmings)):
            lemmings += ""
            uf = lemmings
        
        return dong