from __future__ import annotations
from typing import Literal
from urllib3 import disable_warnings
from datetime import datetime
from time import sleep
from base64 import (
    b64decode
)
import logging
import json
from getpass import getpass
import os

from requests import (
    Response, 
    post, 
    put, 
    get, 
    delete
)

from py4lexis.core.exceptions import (
    Py4LexisAuthException, 
    Py4LexisSessionException, 
    Py4LexisAPIException
)
from py4lexis.core.helper import Clr
from py4lexis.core.kck_session import kck_oi
from py4lexis.core.decorators import handle_class_exceptions
from py4lexis.core.base.common import get_time
from py4lexis.models.tokens import (
    Tokens
)


__all__ = ["LexisSession", "LexisSessionCredentials", "LexisSessionURL", "LexisSessionOffline"]


disable_warnings()
        

class LexisSession():
    
    def __init__(self, 
                 auth_url: str | None=None,
                 realm: str | None=None,
                 client_id: str | None=None,
                 client_secret: str | None=None,
                 zone: str | None = None,
                 login_method: Literal["url", "credentials", "offline"] = "url",
                 suppress_print: bool = False,
                 log_file: str="./lexis_logs.log",
                 log_file_mode: Literal["a", "w"]="a",
                 in_cli: bool=False,                 
                 offline_access: bool=False,
                 refresh_token: str | None=None,
                 username: str | None=None,
                 password: str | None=None,
                 exit_on_error: bool=False) -> None:
        """
            A class holds LEXIS session.

            Attributes
            ----------
            auth_url : str | None
                URL for authorization back-end. 'None' by default.
            realm : str | None
                Realm used for authorization. 'None' by default.
            client_id : str | None
                Keycloak client ID.
            client_secret : str | None
                Keycloak client secret.
            zone: str | None
                iRODS zone. DEFAULT: IT4I iRODS zone.
            login_method: "url" | "credentials | "offline"
                Method used for login the user. 'url' prints out url which is used for login via LEXIS login page. 'credentials' performs login using username/password.
                If 'offline' method is used, existing offline (refresh) token should be passed to 'refresh_token' optional parameter.
            log_file_mode: Literal["a", "w"]
                Set file mode for log file. "a" for append existing one, "w" to overwrite existing one. By default: "a".
            suppress_print: bool
                If False, messages will be printed. DEFAULT: 'False'.
            log_file : str
                Path to a log file. DEFAULT: "./lexis_logs.log"
            in_cli : bool
                Flag if the session is initialised using CLI commands or not. It is set in automated way.
            offline_access : bool
                If offline refresh token has to be acquired or not. 'False' by default.
            refresh_token : str | None
                Parameter that holds existing offline (refresh) token. Should be used when 'offline' login method is selected. 'None' by default.
                Offline/refresh token can also be stored in environment variable called 'PY4LEXIS_TOKEN'.
            username : str | None
                Parameter that holds existing LEXIS username. Should be used when 'credentials' login method is selected. 'None' by default.
            password : str | None
                Parameter that holds password of existing LEXIS user. Should be used when 'credentials' login method is selected. 'None' by default.
            exit_on_error: bool
                If True, program will exit() on error.

            Methods
            -------
            get_access_token() -> str
                Returns the user's access token.

            get_refresh_token() -> str
                Returns the user's refresh (offline) token.

            get_offline_token(self) -> str
                Returns user's offline (refresh) token.

            get_api_headers() -> dict[str, str]
                Returns the API headers for requests.

            get_air_headers() -> dict[str, str]
                Returns API headers for airflow requests.

            refresh_token(refresh_token: str | None=None) -> None
                Refreshes the user's _tokens.            

            logout(refresh_token: str | None=None) -> None:
                Method which logouts the LexisSession in CLI.

            make_request(method: str, 
                         url: str,
                         headers: dict[str, str | int] | None=None,
                         data: dict | None=None,
                         json_data: dict | None=None,
                         params: dict | None=None,
                         to_json: bool=True,
                         stream: bool | None=None,
                         verify: bool | None=None,
                         return_response: bool = False) -> dict | list[dict] | bytes
                Method which handles requests. If token is invalid then it tries to refresh it.
        """
        super().__init__()
        
        self._exit_on_error: bool = exit_on_error

        # Initialise logging
        if not isinstance(suppress_print, bool):
            raise Py4LexisSessionException("'suppress_print' is not a boolean!")
        self.suppress_print: bool = suppress_print

        logging.basicConfig(filename=log_file,
                            filemode=log_file_mode,
                            level=logging.INFO,
                            format='%(asctime)s -- %(levelname)s -- %(name)s -- %(funcName)s -- %(message)s')
        self._logging = logging.getLogger(__name__)
        
        # Helper class
        self.__Clr: Clr = Clr()

        # Username and _tokens
        if not isinstance(in_cli, bool):
            raise Py4LexisSessionException("'in_cli' is not a boolean!")
        self._in_cli = in_cli

        if not isinstance(offline_access, bool):
            raise Py4LexisSessionException("'offline_access' is not a boolean!")
        self._offline_access = offline_access

        if login_method.lower() not in ["url", "credentials", "offline"]:
            raise Py4LexisSessionException(f"Login method can only be one of: {['url', 'credentials', 'offline']}")        

        if login_method == "offline":
            offline_access = True

        self.__uc = kck_oi(in_cli=in_cli, 
                           auth_url=auth_url, 
                           client_id=client_id,
                           client_secret=client_secret,
                           realm=realm,
                           offline_access=offline_access)

        self._tokens: Tokens | None = None
        self.__login(login_method=login_method, 
                     refresh_token=refresh_token,
                     username=username,
                     password=password)       
        
        # Prepare APIs
        if zone is not None and not isinstance(zone, str):
            raise Py4LexisSessionException("'zone' is not a string!")

        self.zone: str = ""
        if zone is None:
            self.zone: str = self.__Clr.get("Z")
        else:
            self.zone: str = zone

        self.api_air: str = self.__Clr.get("AIR")
        self.api_path: str = self.__Clr.get("API")
        self.ddi_path: str = self.__Clr.get("DDI")
        self.irods_path: str = self.__Clr.get("IRDS")
        self.userorg_path: str = self.__Clr.get("USRORG")

        self.__check_api()      


    @handle_class_exceptions()
    def __login(self, 
                login_method: Literal["url", "credentials", "offline"],
                refresh_token: str | None=None,
                username: str | None=None,
                password: str | None=None) -> None:

        if refresh_token is not None and not isinstance(refresh_token, str):
            raise Py4LexisSessionException("'refresh_token' is not a string!")    
        
        if username is not None and not isinstance(username, str):
            raise Py4LexisSessionException("'username' is not a string!")    

        if password is not None and not isinstance(password, str):
            raise Py4LexisSessionException("'password' is not a string!")    

        if not self.suppress_print:
            print("Welcome to the Py4Lexis!")
        self._logging.info(f"SESSION -- LOGIN -- {login_method.upper()}")

        if login_method == "url":            
            self.__login_via_url()
        elif login_method == "credentials":
            self.__login_via_username_password(username=username,
                                               password=password)
        elif login_method == "offline":            
            if refresh_token is None:
                refresh_token = os.environ.get("PY4LEXIS_TOKEN")

            if refresh_token is None:
                self._logging.info("SESSION -- LOGIN -- NO OFFLINE PASSED OR STORED IN ENVIRONMENT VARIABLES. WAITING FOR USER INPUT.")
                print("No offline token was passed or stored in environment variables as 'PY4LEXIS_TOKEN'.")
                refresh_token = input("Insert offline token, please: ")

            self.refresh_token(refresh_token)
        else:
            raise Py4LexisSessionException(f"Unrecognized login method!")

        if not self.suppress_print:
            print("You have been successfully logged in LEXIS session.")

        return None

    @handle_class_exceptions()
    def __login_via_url(self) -> None:
        """
            Login the user via LEXIS login page.

            Returns
            -------
            None
        """
        if not self.suppress_print:
            print("Proceeding login via LEXIS login page...")        

        self._tokens = self.__uc.login()

        return None
    

    def __login_via_username_password(self,
                                      username: str | None=None,
                                      password: str | None=None) -> None:
        """
            Login the user using username/password.

            Returns
            -------
            None
        """
        if not self.suppress_print:
            print("Proceeding login using user's LEXIS credentials...")

        if username is None:
            print(f"No username was passed. Waiting for user's input...")
            username = input(f"Enter LEXIS username: ")
        
        if password is None:
            print(f"No password was passed. Waiting for user's input...")
            password =  getpass(f"Enter password: ")

        self._tokens = self.__uc.login_password(username=username,
                                                password=password)

        return None


    @handle_class_exceptions()
    def __check_api(self) -> None:
        """
            Check if API is working

            Returns
            -------
            None
        """

        response: Response = post(self.ddi_path + b64decode(b"L21ldGEvc2VhcmNo").decode("utf-8"))
        
        if not response.status_code == 401 and not response.status_code == 403:
            raise Py4LexisSessionException(f"API INITIALIZATION FAILED -- SERVER IS PROBABLY OFFLINE")
        
        self._logging.info(f"Initialise API path '{self.ddi_path}' -- OK")                
        
        return None
    

    @handle_class_exceptions()
    def __check_token_expiration(self) -> None:
        """
            Check if access token has expired. If yes, it tries to refresh it.

            Returns
            -------
            None
        """
        if self._tokens is None:
            raise Py4LexisSessionException(f"Tokens are not defined!")
        
        now: float = get_time(datetime.now())
        elapsed: float = now - self._tokens.token_retrieved_at

        if self._tokens.expires_in == 0 or elapsed >= self._tokens.expires_in:
            self.refresh_token()

        return None
                 

    @handle_class_exceptions()
    def get_access_token(self) -> str:
        """
            Returns user's access token.

            Returns
            -------
            str
                User's access token.
        """
        if self._tokens is None:
            raise Py4LexisSessionException(f"Access token is not defined!")
        
        self.__check_token_expiration()

        return self._tokens.access_token  
    

    @handle_class_exceptions()
    def refresh_token(self,
                      refresh_token: str | None=None) -> None:
        """
            Refreshes user's token.

            Returns
            -------
            None
        """

        if refresh_token is None:
            token: str = self.get_refresh_token()               
        else:
            token: str = refresh_token

        self._tokens = self.__uc.rfsh_token(token)

        return None
            

    @handle_class_exceptions()
    def get_refresh_token(self) -> str:
        """
            Returns user's refresh token.

            Returns
            -------
            str
                User's refresh token.
        """
        
        if self._tokens is None:
            raise Py4LexisSessionException(f"Refresh token is not defined!")
        
        now: float = get_time(datetime.now())
        elapsed: float = now - self._tokens.token_retrieved_at

        if self._tokens.refresh_expires_in > 0 and elapsed >= self._tokens.refresh_expires_in:
            raise Py4LexisAuthException(f"Refresh token has expired. Please, relog the session")

        return self._tokens.refresh_token 
               

    @handle_class_exceptions()
    def get_offline_token(self) -> str:
        """
            Returns user's offline (refresh) token.

            Returns
            -------
            str
                User's offline (refresh) token.
        """
        if self._tokens is None:
            raise Py4LexisSessionException(f"Refresh token is not offline token!")
        
        if self._tokens.refresh_expires_in > 0:
            print(f"Refresh token is not offline token!")
            return None
        
        return self.get_refresh_token()


    @handle_class_exceptions()
    def get_api_headers(self, add_content_type=True) -> dict[str, str]:
        """
            Returns API headers for requests.

            Returns
            -------
            dict[str, str]
                API headers.
        """
        
        api_header: dict[str, str] = {
            "Authorization": "Bearer " + self.get_access_token()
        }
        if add_content_type:
            api_header["Content-type"] = b64decode(b"YXBwbGljYXRpb24vanNvbg==").decode("utf-8")

        return api_header
    

    @handle_class_exceptions()
    def get_air_headers(self) -> dict[str, str]:
        """
            Returns API headers for airflow requests.

            Returns
            -------
            dict[str, str]
                API headers.
        """
        
        api_header: dict[str, str] = {
            "X-API-Token": self.get_access_token(),
            "Content-type": b64decode(b"YXBwbGljYXRpb24vanNvbg==").decode("utf-8")
        }

        return api_header
    

    def logout(self,
               refresh_token: str | None=None) -> None:
        """
            Method which logouts the LexisSession in CLI.

            Returns
            -------
            None
        """
        
        if refresh_token is None:
            token: str = self.get_refresh_token()              
        else:
            token: str = refresh_token

        self.__uc.logout(token)

        print("Session was cleared.")  


    def make_request(self, 
                     method: str, 
                     url: str,
                     headers: dict[str, str | int] | None=None,
                     data: dict | None=None,
                     json_data: dict | None=None,
                     params: dict | None=None,
                     to_json: bool=True,
                     stream: bool | None=None,
                     verify: bool | None=None,
                     return_response: bool = False) -> dict | list[dict] | bytes:
        """
            Method which handles requests. If token is invalid then it tries to refresh it.

            Parameters
            ----------
            method : str
                Name of the request method.
            url : str
                URL of the request.
            headers : dict[str, str | int] | None
                Headers for the request. By default is set to None.
            data : dict | None
                General data payload for the request. By default is set to None.
            json_data : dict | None
                Data payload for the request in JSON. By default is set to None.
            to_json : bool | None
                Convert content of response to JSON. By default is set to True.
            steam : bool | None
                If GET is performed as a stream. By default is set to None.
            return_response : bool
                If response should be returned instead of content.
            
            Returns
            -------
            dict | list[dict] | bytes | Response
                Content of the request in JSON dict, list of JSON dicts, RAW content as bytes, or a whole Response should be returned.
        """
        if data is not None:
            self._logging.info(f"Preparing '{method.upper()}' request with the following payload:\n"+
                               f"   {json.dumps(data, indent=2)}")
            
        if json_data is not None:
            self._logging.info(f"Preparing '{method.upper()}' request with the following payload:\n"+
                               f"   {json.dumps(json_data, indent=2)}")
        
        if data is None and json_data is None:
            self._logging.info(f"Preparing '{method.upper()}' request with no payload.")

        status_solved: bool = False
        content: dict | list[dict] | bytes = {}

        retries: int = 0
        max_retries: int = 10
        while not status_solved:
            if method.lower() == "post":
                response: Response = post(url=url, data=data, json=json_data, headers=headers, stream=stream, params=params, verify=verify)
            elif method.lower() == "put":
                response: Response = put(url=url, data=data, json=json_data, headers=headers, stream=stream, params=params, verify=verify)
            elif method.lower() == "get":
                response: Response = get(url=url, data=data, json=json_data, headers=headers, stream=stream, params=params, verify=verify)
            elif method.lower() == "delete":
                response: Response = delete(url=url, data=data, json=json_data, headers=headers, stream=stream, params=params, verify=verify)
            else:
                raise Py4LexisAPIException(f"Unrecognized method: {method.upper()}", method.upper(), url)

            req_status: int = response.status_code

            if req_status == 404:
                raise Py4LexisAPIException(f"Exiting with request status: {req_status} -- NOT FOUND", method.upper(), url)
            
            if req_status >= 500:
                raise Py4LexisAPIException(f"Exiting with request status: {req_status} -- INTERNAL SERVER ERROR", method.upper(), url)

            if req_status > 299:
                try:
                    content = response.json()
                    if "errorString" not in content.keys():
                        raise Py4LexisAPIException(f"Unrecognized problem occurred. Maybe BAD REQUEST? Content: {content}" , method.upper(), url)
                    
                    if content["errorString"] != "Inactive token":
                        raise Py4LexisAPIException(f"Unrecognized 'errorString' obtained in the content: {content['errorString']}" , method.upper(), url)
                    
                    if retries == max_retries:
                        raise Py4LexisAPIException(f"Maximum retries has been reached. User is unauthorized or server is down!" , method.upper(), url)
                     
                    self.refresh_token()                    

                    retries += 1
                    sleep(0.5)

                    if "Authorization" in headers.keys():
                        headers["Authorization"] = f"Bearer {self.get_access_token()}"  
                    
                except json.decoder.JSONDecodeError:
                    raise Py4LexisAPIException(f"Unrecognized problem occurred and content is NOT in JSON. Maybe BAD REQUEST? Content: {response.content}" , method.upper(), url)

            status_solved = True

        if return_response:
            return response

        if to_json:
            content = response.json()
        else:
            content = response.content           
        
        return content       
    

class LexisSessionURL(LexisSession):

    def __init__(self, 
                 auth_url: str | None = None, 
                 client_id: str | None = None,
                 client_secret: str | None = None,
                 realm: str | None = None, 
                 zone: str | None = None, 
                 suppress_print: bool = False, 
                 log_file: str = "./lexis_logs.log", 
                 log_file_mode: Literal["a", "w"]="a",
                 in_cli: bool = False, 
                 offline_access: bool = False,
                 exit_on_error: bool = False) -> None:
        """
            A class holds LEXIS session. Login is provided via LEXIS Login page (URL is provided to log in).

            Attributes
            ----------
            auth_url : str | None
                URL for authorization back-end. 'None' by default.
            realm : str | None
                Realm used for authorization. 'None' by default.
            client_id : str | None
                Keycloak client ID.
            client_secret : str | None
                Keycloak client secret.
            zone: str | None
                iRODS zone. DEFAULT: IT4I iRODS zone.
            suppress_print: bool
                If False, messages will be printed. DEFAULT: 'False'.
            log_file : str
                Path to a log file. DEFAULT: "./lexis_logs.log"
            log_file_mode: Literal["a", "w"]
                Set file mode for log file. "a" for append existing one, "w" to overwrite existing one. By default: "a".
            in_cli : bool
                Flag if the session is initialised using CLI commands or not. It is set in automated way.
            offline_access : bool
                If offline token has to be acquired or not. 'False' by default.
            exit_on_error: bool
                If True, program will exit() on error.

            Methods
            -------
            get_access_token() -> str
                Returns the user's access token.

            get_refresh_token() -> str
                Returns the user's refresh (offline) token.

            get_offline_token(self) -> str
                Returns user's offline (refresh) token.

            get_api_headers() -> dict[str, str]
                Returns the API headers for requests.

            get_air_headers() -> dict[str, str]
                Returns API headers for airflow requests.

            refresh_token(refresh_token: str | None=None) -> None
                Refreshes the user's _tokens.            

            logout(refresh_token: str | None=None) -> None:
                Method which logouts the LexisSession in CLI.

            make_request(method: str, 
                         url: str,
                         headers: dict[str, str | int] | None=None,
                         data: dict | None=None,
                         json_data: dict | None=None,
                         params: dict | None=None,
                         to_json: bool=True,
                         stream: bool | None=None,
                         verify: bool | None=None,
                         return_response: bool = False) -> dict | list[dict] | bytes
                Method which handles requests. If token is invalid then it tries to refresh it.
        """
        super().__init__(auth_url=auth_url, 
                         realm=realm, 
                         client_id=client_id,
                         client_secret=client_secret,
                         zone=zone, 
                         login_method="url", 
                         suppress_print=suppress_print, 
                         log_file=log_file, 
                         log_file_mode=log_file_mode,
                         in_cli=in_cli, 
                         offline_access=offline_access, 
                         refresh_token=None, 
                         username=None, 
                         password=None,
                         exit_on_error=exit_on_error)


class LexisSessionCredentials(LexisSession):

    def __init__(self, 
                 auth_url: str | None = None, 
                 realm: str | None = None, 
                 client_id: str | None = None,
                 client_secret: str | None = None,
                 zone: str | None = None, 
                 suppress_print: bool = False, 
                 log_file: str = "./lexis_logs.log", 
                 log_file_mode: Literal["a", "w"]="a",
                 in_cli: bool = False, 
                 offline_access: bool = False, 
                 username: str | None = None, 
                 password: str | None = None,
                 exit_on_error: bool = False) -> None:
        """
            A class holds LEXIS session.

            Attributes
            ----------
            auth_url : str | None
                URL for authorization back-end. 'None' by default.
            realm : str | None
                Realm used for authorization. 'None' by default.
            client_id : str | None
                Keycloak client ID.
            client_secret : str | None
                Keycloak client secret.
            zone: str | None
                iRODS zone. DEFAULT: IT4I iRODS zone.
            suppress_print: bool
                If False, messages will be printed. DEFAULT: 'False'.
            log_file : str
                Path to a log file. DEFAULT: "./lexis_logs.log"
            log_file_mode: Literal["a", "w"]
                Set file mode for log file. "a" for append existing one, "w" to overwrite existing one. By default: "a".
            in_cli : bool
                Flag if the session is initialised using CLI commands or not. It is set in automated way.
            offline_access : bool
                If offline refresh token has to be acquired or not. 'False' by default.
            username : str | None
                Parameter that holds existing LEXIS username. Should be used when 'credentials' login method is selected. 'None' by default.
            password : str | None
                Parameter that holds password of existing LEXIS user. Should be used when 'credentials' login method is selected. 'None' by default.
            exit_on_error: bool
                If True, program will exit() on error.

            Methods
            -------
            get_access_token() -> str
                Returns the user's access token.

            get_refresh_token() -> str
                Returns the user's refresh (offline) token.

            get_offline_token(self) -> str
                Returns user's offline (refresh) token.

            get_api_headers() -> dict[str, str]
                Returns the API headers for requests.

            get_air_headers() -> dict[str, str]
                Returns API headers for airflow requests.

            refresh_token(refresh_token: str | None=None) -> None
                Refreshes the user's _tokens.            

            logout(refresh_token: str | None=None) -> None:
                Method which logouts the LexisSession in CLI.

            make_request(method: str, 
                         url: str,
                         headers: dict[str, str | int] | None=None,
                         data: dict | None=None,
                         json_data: dict | None=None,
                         params: dict | None=None,
                         to_json: bool=True,
                         stream: bool | None=None,
                         verify: bool | None=None,
                         return_response: bool = False) -> dict | list[dict] | bytes
                Method which handles requests. If token is invalid then it tries to refresh it.
        """
        super().__init__(auth_url=auth_url, 
                         realm=realm, 
                         client_id=client_id,
                         client_secret=client_secret,
                         zone=zone, 
                         login_method="credentials", 
                         suppress_print=suppress_print, 
                         log_file=log_file, 
                         log_file_mode=log_file_mode,
                         in_cli=in_cli, 
                         offline_access=offline_access, 
                         refresh_token=None, 
                         username=username, 
                         password=password,
                         exit_on_error=exit_on_error)


class LexisSessionOffline(LexisSession):
    
    def __init__(self, 
                 auth_url: str | None = None, 
                 realm: str | None = None, 
                 client_id: str | None = None,
                 client_secret: str | None = None,
                 zone: str | None = None, 
                 suppress_print: bool = False, 
                 log_file: str = "./lexis_logs.log",
                 log_file_mode: Literal["a", "w"]="a", 
                 in_cli: bool = False, 
                 refresh_token: str | None = None,
                 exit_on_error: bool = False) -> None:
        """
            A class holds LEXIS session. Authentication is provided by offline (refresh) token. Can be used classic refresh token.

            Attributes
            ----------
            auth_url : str | None
                URL for authorization back-end. 'None' by default.
            realm : str | None
                Realm used for authorization. 'None' by default.
            client_id : str | None
                Keycloak client ID.
            client_secret : str | None
                Keycloak client secret.
            zone: str | None
                iRODS zone. DEFAULT: IT4I iRODS zone.
            suppress_print: bool
                If False, messages will be printed. DEFAULT: 'False'.
            log_file : str
                Path to a log file. DEFAULT: "./lexis_logs.log"
            log_file_mode: Literal["a", "w"]
                Set file mode for log file. "a" for append existing one, "w" to overwrite existing one. By default: "a".
            in_cli : bool
                Flag if the session is initialised using CLI commands or not. It is set in automated way.
            refresh_token : str | None
                Parameter that holds existing offline (refresh) token. 'None' by default.
                Offline/refresh token can also be stored in environment variable called 'PY4LEXIS_TOKEN'.
            exit_on_error: bool
                If True, program will exit() on error.

            Methods
            -------
            get_access_token() -> str
                Returns the user's access token.

            get_refresh_token() -> str
                Returns the user's refresh (offline) token.

            get_offline_token(self) -> str
                Returns user's offline (refresh) token.

            get_api_headers() -> dict[str, str]
                Returns the API headers for requests.

            get_air_headers() -> dict[str, str]
                Returns API headers for airflow requests.

            refresh_token(refresh_token: str | None=None) -> None
                Refreshes the user's _tokens.            

            logout(refresh_token: str | None=None) -> None:
                Method which logouts the LexisSession in CLI.

            make_request(method: str, 
                         url: str,
                         headers: dict[str, str | int] | None=None,
                         data: dict | None=None,
                         json_data: dict | None=None,
                         params: dict | None=None,
                         to_json: bool=True,
                         stream: bool | None=None,
                         verify: bool | None=None,
                         return_response: bool = False) -> dict | list[dict] | bytes
                Method which handles requests. If token is invalid then it tries to refresh it.
        """
        super().__init__(auth_url=auth_url, 
                         realm=realm, 
                         client_id=client_id,
                         client_secret=client_secret,
                         zone=zone, 
                         login_method="offline", 
                         suppress_print=suppress_print, 
                         log_file=log_file, 
                         log_file_mode=log_file_mode,
                         in_cli=in_cli, 
                         offline_access=True, 
                         refresh_token=refresh_token, 
                         username=None, 
                         password=None,
                         exit_on_error=exit_on_error)