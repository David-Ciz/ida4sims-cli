
from __future__ import annotations

from typing import Literal
from datetime import (
    datetime, 
    date
)
from logging import (
    Logger, 
    getLogger
)
import os

from pandas import DataFrame

import irods.keywords as kw
from irods.session import iRODSSession
from irods.data_object import iRODSDataObject
from irods.collection import iRODSCollection

from py4lexis.core.decorators import (
    handle_class_exceptions,
    handle_common_variables
)
from py4lexis.core.exceptions import Py4LexisiRODSException
from py4lexis.core.helper import (
    Clr, 
    _irds_brkr, 
    _prvdr,  
    _irds, 
    _irds_prt, 
    _sc
)
from py4lexis.session import (
    LexisSession,
    LexisSessionURL,
    LexisSessionOffline,
    LexisSessionCredentials
)
from py4lexis.core.utils import (
    ProgressBar,
    assemble_dataset_path, 
    printProgressBar
)
from py4lexis.core.base.paths import (
    create_path, 
    make_abs_path, 
    pure_path
)
from py4lexis.core.base.validators import (
    check_action_type,
    check_if_uuid,
    check_access,
    is_string,
    is_dictionary,
    is_bool
)

from py4lexis.core.typings.ddi import (
    Access
)

from py4lexis.ddi.datasets import Datasets
from py4lexis.core.userorg import get_location_and_resource_by_zone, get_zone_by_location


class iRODS():

    def __init__(self, 
                 session: LexisSession | LexisSessionURL | LexisSessionOffline | LexisSessionCredentials,
                 host: str | None=None,
                 port: str | None=None,
                 zone: str | None=None,
                 suppress_print: bool=True,
                 exit_on_error: bool=False) -> None:
        """
            A class holds methods to manage objects and collections within iRODSSession.

            NOTE: Usage of private class _irds (instance of iRODSSession) on your own risk! For example,
            creating new dataset in LEXIS cannot be done by use of _irds.create_collection('NEW_DATASET')! 
            Such a dataset will not be visible within LEXIS 

            Attributes
            ----------
            session : class
                Class that holds LEXIS session.
            host : str | None
                HOST URL for the iRODS session.
            port : str | None
                Port for the iRODS session.
            zone : str | None
                Zone withing iRODS session.
            suppress_print : bool
                If prints should be suppressed or not. By default 'False'.
            exit_on_error: bool
                If True, program will exit() on error.

            Methods
            -------
            put_data_object_to_dataset(local_filepath: str,
                                       dataset_filepath: str,
                                       access: Literal["public", "project", "user"],
                                       project: str,
                                       dataset_id: str,
                                       zone: str | None=None,
                                       overwrite: bool=False,
                                       override_suppress_print: bool=False) -> iRODSDataObject | None
                Put an object from local to LEXIS dataset via iRODS.
                Parallel transfer is automatically enabled for data objects with 32+ MB.

            get_data_object_from_dataset(dataset_filepath: str,
                                         access: Literal["public", "project", "user"],
                                         project: str,
                                         dataset_id: str,
                                         local_filepath: str | None=None,
                                         zone: str | None=None,
                                         override_suppress_print: bool=False) -> iRODSDataObject | None
                Get an object from LEXIS dataset to local via iRODS.
                Parallel transfer is automatically enabled for data objects with 32+ MB.

           upload_directory_to_dataset(local_directorypath: str,
                                       access: Literal["public", "project", "user"],
                                       project: str,
                                       dataset_id: str,
                                       dataset_directorypath: str | None=None,
                                       zone: str | None=None,
                                       overwrite: bool=False) -> None
                Upload whole directory with subdirectories and data objects from local to LEXIS dataset via iRODS.
                If no dataset_path is defined, then path within the dataset will start by 'directory name' which has to be uploaded.
                Parallel transfer is automatically enabled for data objects with 32+ MB.

            download_dataset_as_directory(access: Literal["public", "project", "user"],
                                          project: str,
                                          dataset_id: str,
                                          local_filepath: str | None=None,
                                          dataset_directorypath: str | None=None,
                                          zone: str | None=None,
                                          override_suppress_print: bool=False) -> None
                Downloads whole dataset as directory.
                NOTE: Empty directories will be ignored.

            create_dataset(access: Literal["public", "project", "user"], 
                           project: str, 
                           zone: str | None=None,
                           dataset_type : str | None=None,
                           additional_metadata : dict | str | None=None,
                           datacite: dict | None=None,
                           title: str=str("UNTITLED_Dataset_" + datetime.now().strftime("%d-%m-%Y_%H:%M:%S"))) -> dict[str, str | int]
                Creates an empty LEXIS dataset with specified attributes, prints out dataset ID of created datasets and returns requests content with its status.
                NOTE: The method is based Datasets class in py4lexis.ddi.

            create_dataset_and_upload_directory(access: Literal["public", "project", "user"], 
                                                project: str,
                                                local_directorypath: str,
                                                zone: str | None=None,                                            
                                                dataset_directorypath: str | None=None,
                                                dataset_type : str | None=None,
                                                additional_metadata : dict | str | None=None,
                                                datacite: dict | None=None,
                                                title: str=str("UNTITLED_Dataset_" + datetime.now().strftime("%d-%m-%Y_%H:%M:%S"))) -> dict:
                Creates an empty LEXIS dataset with specified attributes and perform upload of defined directory with subdirectories and data objects from local to LEXIS dataset via iRODS.
                If no dataset_path is defined, then path within the dataset will start by 'directory name' which has to be uploaded.
                Parallel transfer is automatically enabled for data objects with 32+ MB.
                
            create_directory_within_dataset(dataset_directory_path: str,
                                            access: Literal["public", "project", "user"],
                                            project: str,
                                            dataset_id: str,
                                            zone: str | None=None,
                                            recurse: bool=True) -> iRODSCollection | None
                Create a directory (collection) within LEXIS dataset via iRODS.

            get_project_collection(access: Literal["public", "project", "user"],
                                   project: str,
                                   zone: str | None=None) -> iRODSCollection | None
                Get LEXIS project as a collection.

            get_dataset_colletion(access: Literal["public", "project", "user"],
                                  project: str,
                                  dataset_id: str,
                                  zone: str | None=None) -> iRODSCollection | None
                Get LEXIS dataset as a collection.
        """

        self._exit_on_error: bool = exit_on_error
        self._logging: Logger = getLogger(__name__)
        self._host: str | None = host
        self._port: str | None = port
        self._suppress_print: bool = suppress_print
        self._default_zone: str = session.zone if zone is None else zone
        self.__session: LexisSession | LexisSessionURL | LexisSessionOffline | LexisSessionCredentials = session
        self.__Clr: Clr = Clr()                
        self.__irds: iRODSSession = self.__get_irds_session()                
        

    @handle_class_exceptions()
    def __validate_irds(self) -> bool:
        """
            Validate token at iRODS broker.
        """
        if not self.__session.suppress_print:
            print(f"Validating token on iRODS...")
        
        self._logging.info("iRODS -- VALIDATE TOKEN -- PROGRESS")

        if "msad" in self.__session.irods_path:
            url: str = f"https://{self.__session.irods_path}/validate_token"
        else:
            url: str = f"{self.__session.api_path}/broker/validate_token"

        get_params: dict[str, str] = {
            "provider": self.__Clr.yhbrr(_prvdr),
            "access_token": self.__session.get_access_token()
        }

        content: dict | list[dict] | bytes = self.__session.make_request("get", url, params=get_params, verify=False, to_json=True)

        if content["active"]:
            if not self.__session.suppress_print:
                print(f"Validate token on iRODS was successfull...")
            
            self._logging.info("iRODS -- VALIDATE TOKEN -- OK")

            return True
        else:
            return False


    @handle_class_exceptions()
    def __get_irds_session(self) -> iRODSSession:
        """
            Retrieve iRODS session.
        """

        if self.__validate_irds():
            irods_session: iRODSSession = iRODSSession(host=self.__session.irods_path if self._host is None else self._host,
                                                       port=int(self.__Clr.yhbrr(_irds_prt)) if self._port is None else self._port,
                                                       authentication_scheme=self.__Clr.yhbrr(_sc),
                                                       openid_provider=self.__Clr.yhbrr(_prvdr),
                                                       zone=self._default_zone,
                                                       access_token=self.__session.get_access_token(),
                                                       user=self.__session._tokens.username,
                                                       block_on_authURL=False)

            if not self.__session.suppress_print:
                print(f"The iRODS session was successfully initialised.")
            
            self._logging.info("iRODS -- INITIALISED -- OK")

            return irods_session
        else:
            raise Py4LexisiRODSException("INITIALISED -- token on iRODS is not active -- FAILED")


    def __create_collection_with_log(self, 
                                     irods_directory_path: str) -> iRODSCollection | None:
        """
            Creates collection wrapped by logs.

            Parameters
            ----------
            irods_directory_path : str
                Path within iRODS instance.

            Returns
            -------
            iRODSCollection | None
                Returns iRODS collection or None.
        """
        self._logging.info(f"Creating directory within dataset: {irods_directory_path}")
        self.__irds.collections.create(path=irods_directory_path, 
                                        recurse=True)
        self._logging.info(f"Direcotry was created")


    def __get_collection_with_log(self, 
                                  irods_path: str, 
                                  zone: str) -> iRODSCollection:
        self._logging.info(f"GET iRODS collection: {irods_path}")
        collection: iRODSCollection | None = self.__irds.collections.get(path=irods_path)

        if collection is None:
            raise Py4LexisiRODSException(f"No iRODS collection {irods_path} found in zone {zone}!")
        
        return collection

    
    def __get_data_object_with_log(self, 
                                   irods_filepath: str, 
                                   local_directory_path: str) -> iRODSDataObject | None:
        """
            Does iRODS GET data object request wrapped by logs.

            Parameters
            ----------
            irods_filepath : str
                File path within the iRODS instance.
            local_directory_path : str
                Path to the directory in local machine.

            Returns
            -------
            iRODSDataObject | None
                Returns iRODS data object or None.
        """
        self._logging.info(f"Downloading object\n" + 
                          f"    from dataset: {irods_filepath}\n"+
                          f"    to local: {local_directory_path}")
        data_object: iRODSDataObject = self.__irds.data_objects.get(path=irods_filepath, 
                                                                     local_path=local_directory_path,
                                                                     forceFlag=kw.FORCE_FLAG_KW)
        self._logging.info(f"Object was downloaded")
        return data_object


    def __put_data_object_with_log(self, 
                                   local_filepath: str, 
                                   irods_directory_path: str,
                                   overwrite: bool=False) -> iRODSDataObject | None:
        """
            Does iRODS PUT request wrapped by logs.

            Parameters
            ----------
            local_filepath : str
                Path to the file in local machine.
            irods_directory_path : str
                Directory path within the iRODS instance. 
            overwrite : bool          
                If existing data object should be rewritten. 'False' by default.

            Returns
            -------
            iRODSDataObject | None
                Returns iRODS data object or None.
        """
        self._logging.info(f"Uploading object"+
                          f"   from local: {local_filepath}\n"+
                          f"   to dataset: {irods_directory_path}")
        irods_data_object_path: str = os.path.join(irods_directory_path, os.path.basename(local_filepath))
        if self.__irds.data_objects.exists(irods_data_object_path) and overwrite:
            irods_object: iRODSDataObject = self.__irds.data_objects.get(irods_data_object_path)
            irods_object.unregister(force=True)
        data_object: iRODSDataObject = self.__irds.data_objects.put(local_path=local_filepath, 
                                                                     irods_path=irods_directory_path)
        self._logging.info(f"Object was uploaded")
        return data_object
    

    @handle_class_exceptions()
    def __download_collection_content(self,
                                      collection: iRODSCollection, 
                                      local_directorypath: str,
                                      irods_path: str,
                                      progress_bar: ProgressBar) -> None:
        
        for irods_object in collection.data_objects:
            target_path: str = local_directorypath + irods_object.path.replace(irods_path, "")
            self.__get_data_object_with_log(irods_object.path, target_path)

            if not self._suppress_print:
                progress_bar.print_progress(suffix=f"({irods_object.path}/{irods_object.name})")

        for subcollection in collection.subcollections:
            target_path: str = local_directorypath + subcollection.path.replace(irods_path, "")
            create_path(target_path, is_dir=True)

            if not self._suppress_print:
                progress_bar.print_progress(suffix=f"({target_path})")

            self.__download_collection_content(collection=subcollection,
                                               local_directorypath=local_directorypath,
                                               irods_path=irods_path,
                                               progress_bar=progress_bar)

        return None


    @handle_class_exceptions()
    @handle_common_variables()
    def put_data_object_to_dataset(self,
                                   local_filepath: str,
                                   dataset_filepath: str,
                                   access: Access,
                                   project: str,
                                   dataset_id: str,
                                   zone: str | None=None,
                                   overwrite: bool=False,
                                   override_suppress_print: bool=False) -> iRODSDataObject | None:
        """
            Puts an object from local to LEXIS dataset via iRODS.
            Parallel transfer is automatically enabled for data objects with 32+ MB.

            Parameters
            ----------
            local_filepath: str
                Path (relative or absolute) of a file in local machine.
            dataset_filepath: str
                Path (relative) within LEXIS dataset where the file should be put.
            access: Literal["public", "project", "user"]
                Access type defined for a dataset.
            project: str
                LEXIS project's shortname.
            dataset_id: str
                Dataset's dataset ID (UUID).
            zone: str | None
                iRODS zonename. If None, then: 'IT4ILexisV2' is used.
            override_suppress_print: bool
                Override suppress print option. By default is set to False.
            overwrite : bool          
                If existing data object should be rewritten. 'False' by default.

            Returns
            -------
            iRODSDataObject | None
        """

        local_filepath = is_string(parameter_name="local_filepath",
                                   parameter=local_filepath,
                                   log=self._logging)

        dataset_filepath = is_string(parameter_name="dataset_filepath",
                                     parameter=dataset_filepath,
                                     log=self._logging)
        
        access = check_access(access=access,
                              log=self._logging)
        
        project = is_string(parameter_name="project",
                            parameter=project,
                            log=self._logging)
        
        dataset_id = check_if_uuid(uuid=dataset_id,
                                   parameter_name="dataset_id",
                                   log=self._logging)
        
        zone = is_string(parameter_name="zone",
                         parameter=zone,
                         log=self._logging)
        
        overwrite = is_bool(parameter_name="overwrite",
                            parameter=overwrite,
                            log=self._logging)
        
        override_suppress_print = is_bool(parameter_name="override_suppress_print",
                                          parameter=override_suppress_print,
                                          log=self._logging)

        username: str | None = None
        if access == "user":
            username = self.__session._tokens.username
        
        irods_path: str = assemble_dataset_path(access=access,
                                                project=project,
                                                dataset_id=dataset_id,
                                                username=username)

        # assemble dataset path
        dataset_filepath = pure_path(dataset_filepath)
        irods_path: str = f"/{zone}/{irods_path}"

        if dataset_filepath != "":
            irods_path: str = f"{irods_path}/{dataset_filepath}"

        # assemble file path
        local_filepath = make_abs_path(local_filepath)
        
        if not os.path.exists(local_filepath):
            raise Py4LexisiRODSException(f"Local file path does not exist! Path: {local_filepath}")

        if not self._suppress_print and not override_suppress_print:
            print(f"Uploading data object...\n"+
                  f"    from: {local_filepath}\n"+
                  f"    to: {irods_path}")
        
        data_object: iRODSDataObject = self.__put_data_object_with_log(local_filepath=local_filepath,
                                                                       irods_directory_path=irods_path,
                                                                       overwrite=overwrite)

        if not self._suppress_print and not override_suppress_print:
            print("Upload was successfull...")
                  
        return data_object


    @handle_class_exceptions()
    @handle_common_variables()
    def get_data_object_from_dataset(self,
                                     dataset_filepath: str,
                                     access: Access,
                                     project: str,
                                     dataset_id: str,
                                     local_filepath: str | None=None,
                                     zone: str | None=None,
                                     override_suppress_print: bool=False) -> iRODSDataObject | None:
        """
            Gets an object from LEXIS dataset to local via iRODS.
            Parallel transfer is automatically enabled for data objects with 32+ MB.

            Parameters
            ----------
            dataset_filepath: str
                Path (relative) within LEXIS dataset where the file can be found.
            access: Literal["public", "project", "user"]
                Access type defined for a dataset.
            project: str
                LEXIS project's shortname.
            dataset_id: str
                Dataset's dataset ID (UUID).
            local_filepath: str | None
                Path (relative or absolute) for a file in local machine which will be used for download.
                If 'None', then the path will be relative (in CWD) starting by dataset's dataset ID.
            zone: str | None
                iRODS zonename. If None, then: 'IT4ILexisV2' is used.
            override_suppress_print: bool
                Override suppress print option. By default is set to False.

            Returns
            -------
            iRODSDataObject | None
        """

        local_filepath = is_string(parameter=local_filepath,
                                   parameter_name="local_filepath",
                                   log=self._logging)
        
        dataset_filepath = is_string(parameter=dataset_filepath,
                                     parameter_name="dataset_filepath",
                                     log=self._logging)
        
        access = check_access(access=access,
                              log=self._logging)
        
        project = is_string(parameter=project,
                            parameter_name="project",
                            log=self._logging)
        
        dataset_id = check_if_uuid(uuid=dataset_id,
                                   parameter_name="dataset_id",
                                   log=self._logging)
        
        zone = is_string(parameter=zone,
                         parameter_name="zone",
                         log=self._logging)
        
        override_suppress_print = is_bool(parameter=override_suppress_print,
                                          parameter_name="override_suppress_print",
                                          log=self._logging)
        
        username: str | None = None
        if access == "user":
            username = self.__session._tokens.username
        
        irods_path: str = assemble_dataset_path(access=access,
                                                project=project,
                                                dataset_id=dataset_id,
                                                username=username)

        # assemble dataset path
        dataset_filepath = pure_path(dataset_filepath)
        irods_path = f"/{zone}/{irods_path}"

        if dataset_filepath != "":
            irods_path = f"{irods_path}/{dataset_filepath}"

        # assemble file path
        if local_filepath is None:
            local_filepath: str = f"{pure_path(os.getcwd())}/{dataset_id}/{dataset_filepath}"
        else:
            local_filepath: str = f"{local_filepath}/{dataset_filepath}"

        local_filepath = create_path(local_filepath)            
                    
        # do request
        if not self._suppress_print and not override_suppress_print:
            print(f"Downloading data object...\n"+
                  f"    from: {irods_path}\n"+
                  f"    to: {local_filepath}")
            
        data_object: iRODSDataObject = self.__get_data_object_with_log(irods_path, local_filepath)
        
        if not self._suppress_print and not override_suppress_print:
            print("Download was successfull...")

        return data_object


    @handle_class_exceptions()
    @handle_common_variables()
    def upload_directory_to_dataset(self,
                                    local_directorypath: str,
                                    access: Access,
                                    project: str,
                                    dataset_id: str,
                                    dataset_directorypath: str | None=None,
                                    zone: str | None=None,
                                    overwrite: bool=False) -> None:
        """
            Uploads whole directory with subdirectories and data objects from local to LEXIS dataset via iRODS.
            If no dataset_path is defined, then path within the dataset will start by 'directory name' which has to be uploaded.
            Parallel transfer is automatically enabled for data objects with 32+ MB.

            Parameters
            ----------
            local_directorypath: str
                Path (absolute or relative) of a directory in local machine.
            access: Literal["public", "project", "user"]
                Access type defined for a dataset.
            project: str
                LEXIS project's shortname.
            dataset_id: str
                Dataset's dataset ID (UUID).
            dataset_directorypath : str | None
                Path (relative) within dataset to which a directory will be uploaded. If 'None', then by default is set to root.
            zone: str | None
                iRODS zonename. If None, then: 'IT4ILexisV2' is used.
            overwrite : bool          
                If existing data objects should be rewritten. 'False' by default.

            Returns
            -------
            None
        """

        local_directorypath = is_string(parameter=local_directorypath,
                                        parameter_name="local_directorypath",
                                        log=self._logging)
        
        access = check_access(access=access,
                              log=self._logging)
        
        project = is_string(parameter=project,
                            parameter_name="project",
                            log=self._logging)
        
        dataset_id = check_if_uuid(uuid=dataset_id,
                                   parameter_name="dataset_id",
                                   log=self._logging)
        
        dataset_directorypath = is_string(parameter=dataset_directorypath,
                                          parameter_name="dataset_directorypath",
                                          log=self._logging)
        
        zone = is_string(parameter=zone,
                         parameter_name="zone",
                         log=self._logging)
        
        overwrite = is_bool(parameter=overwrite,
                            parameter_name="overwrite",
                            log=self._logging)

        username: str | None = None
        if access == "user":
            username = self.__session._tokens.username

        local_directorypath = make_abs_path(local_directorypath)

        if not os.path.exists(local_directorypath):
            raise Py4LexisiRODSException(f"Local directory path does not exist! Path: {local_directorypath}")

        tmp_str: str = local_directorypath.split("/") 
        directory_name: str = tmp_str[-1]

        if not self._suppress_print:
            print(f"Uploading whole directory: {directory_name}\n"+
                  f"               located at: {local_directorypath}\n")
                  
        # Assemble paths -------------------------------------------------------------------------------------------------
        irods_path: str = assemble_dataset_path(access=access,
                                                project=project,
                                                dataset_id=dataset_id,
                                                username=username)
        irods_path = f"/{zone}/{irods_path}"

        if dataset_directorypath is not None:
            dataset_directorypath = pure_path(dataset_directorypath)

            if dataset_directorypath != "":
                irods_path = f"{irods_path}/{dataset_directorypath}"

        count_dirs_and_files: int = 0
        if not self._suppress_print:
            # initialize number of elements for progressBar
            directory_iterator = os.walk(f"{local_directorypath}")
            
            for item_i in directory_iterator:
                count_dirs_and_files += 1
                count_dirs_and_files += len(item_i[2])

        directory_iterator = os.walk(f"{local_directorypath}")

        # UPLOAD ROUTINE -------------------------------------------------------------------------------------------------
        progress_bar: ProgressBar = ProgressBar(total=count_dirs_and_files,
                                                prefix="Uploading: ",
                                                length=50)
        if not self._suppress_print:            
            progress_bar.print_progress(suffix="")

        for item_i in directory_iterator:
            directory_path: str = item_i[0].split(f"/{directory_name}")[1].replace("\\", "/")  # replace due to win32 path
            data_objects: list[str] = item_i[2]

            irods_directory_path: str = f"{irods_path}/{directory_name}"
            if directory_path != "":
                irods_directory_path: str = f"{irods_directory_path}{directory_path}"
            
            self.__create_collection_with_log(irods_directory_path)

            if not self._suppress_print:
                progress_bar.print_progress(suffix=f"({irods_directory_path})")

            for data_object in data_objects:
                local_object_path: str = f"{item_i[0]}/{data_object}"

                irods_object_path: str = f"{irods_directory_path}/{data_object}"

                self.__put_data_object_with_log(local_filepath=local_object_path, 
                                                irods_directory_path=irods_directory_path,
                                                overwrite=overwrite)
                
                if not self._suppress_print:
                    progress_bar.print_progress(suffix=f"({irods_object_path})")

        if not self._suppress_print:
            print(f"Uploading done...")

        return None
    

    @handle_class_exceptions()
    @handle_common_variables()
    def download_dataset_as_directory(self,
                                      access: Access,
                                      project: str,
                                      dataset_id: str,
                                      local_directorypath: str | None=None,
                                      dataset_directorypath: str | None=None,
                                      zone: str | None=None) -> None:
        """
            Downloads whole dataset as directory.

            Parameters
            ----------
            access: Literal["public", "project", "user"]
                Access type defined for a dataset.
            project: str
                LEXIS project's shortname.
            dataset_id: str
                Dataset's dataset ID (UUID).
            local_directorypath: str | None
                Path (relative or absolute) for a directory in local machine which will be used for download.
                If 'None', then the path will be relative (in CWD) starting by dataset's dataset ID (or defined root directory if dataset_directorypath is defined).
            dataset_directorypath : str | None
                Path (relative) within dataset to from which the download will start. If 'None', then by default is set to root.
            zone: str | None
                iRODS zonename. If None, then: 'IT4ILexisV2' is used.

            Returns
            -------
            None
        """
        access = check_access(access=access,
                              log=self._logging)
        
        project = is_string(parameter=project,
                            parameter_name="project",
                            log=self._logging)
        
        dataset_id = check_if_uuid(uuid=dataset_id,
                                   parameter_name="dataset_id",
                                   log=self._logging)
        
        local_directorypath = is_string(parameter=local_directorypath,
                                        parameter_name="local_directorypath",
                                        log=self._logging)
        
        dataset_directorypath = is_string(parameter=dataset_directorypath,
                                          parameter_name="dataset_directorypath",
                                          log=self._logging)
        
        zone = is_string(parameter=zone,
                         parameter_name="zone",
                         log=self._logging)

        ds: Datasets = Datasets(session=self.__session)
        content: DataFrame = ds.get_content_of_dataset(dataset_id=dataset_id,
                                                       content_as_pandas=True)
        
        # ASSEMBLE PATHS ---------------------------------------------------------------------------------------
        if not self._suppress_print:
            print(f"Preparing paths for download...")

        username: str | None = None
        if access == "user":
            username = self.__session._tokens.username
        
        irods_path: str = assemble_dataset_path(access=access,
                                                project=project,
                                                dataset_id=dataset_id,
                                                username=username)
        
        full_irds_path: str = f"/{zone}/{irods_path}"            
        if dataset_directorypath is not None and dataset_directorypath != "":
            full_irds_path = f"/{zone}/{irods_path}/{dataset_directorypath}"

        collection: iRODSCollection = self.__get_collection_with_log(full_irds_path, zone)

        count_dirs_and_files: int = 0
        for content in collection.walk():
            count_dirs_and_files = count_dirs_and_files + 1 + len(content[2])       
        count_dirs_and_files -= 1 # subtract root dir

        if local_directorypath is not None:
            local_directorypath = make_abs_path(local_directorypath)
        else:
            local_directorypath = f"{pure_path(os.getcwd())}"

        if dataset_directorypath is not None:
            local_directorypath = f"{local_directorypath}/{dataset_directorypath}"
        else:
            local_directorypath = f"{local_directorypath}/{dataset_id}"

        local_directorypath = create_path(local_directorypath, is_dir=True)

        if not self._suppress_print:
            print(f"Downloading whole dataset: {full_irds_path}\n"+
                  f"                       to: {local_directorypath}\n")

        # DOWNLOAD ROUTINE ---------------------------------------------------------------------------------------------------
        progress_bar: ProgressBar = ProgressBar(total=count_dirs_and_files,
                                                prefix="Downloading: ",
                                                length=50)
        if not self._suppress_print:
                progress_bar.print_progress()

        self.__download_collection_content(collection=collection,
                                           local_directorypath=local_directorypath,
                                           irods_path=full_irds_path,
                                           progress_bar=progress_bar)

        if not self._suppress_print:
            print(f"Downloading done. Dataset was downloaded to: {local_directorypath}")

        return None   


    @handle_class_exceptions()
    @handle_common_variables()
    def create_dataset(self,
                       access: Access, 
                       project: str, 
                       zone: str | None=None,
                       dataset_type : str | None=None,
                       additional_metadata : dict | str | None=None,
                       datacite: dict | None=None,
                       title: str=str("UNTITLED_Dataset_" + datetime.now().strftime("%d-%m-%Y_%H:%M:%S"))) -> dict:

        """
            Creates an empty dataset with specified attributes.
            
            NOTE: The method is based Datasets class in py4lexis.ddi.

            Parameters
            ----------
            access : Literal["public", "project", "user"], 
                Access type for the dataset.
            project: str, 
                LEXIS project's shortname.
            zone: str | None
                iRODS zonename. If None, then: 'IT4ILexisV2' is used.
            dataset_type : str | None=None,
                Type of the dataset. Example value can be, e.g., 'dataset'.
            additional_metadata : dict | str | None=None,
                Additional (arbitrary) metadata of the dataset. It should be keyword dictionary, 
                where key is the metadata name and value is the metadata value. Could be 
                also passed as JSON string.
            datacite: dict | str | None=None,
                Datacite metadata of the dataset. It should correspond to the Datacite schema,
                which can be be generated by DataCite model within Py4Lexis.
                Could be also passed as JSON string.
            title: str=str("UNTITLED_Dataset_" + datetime.now().strftime("%d-%m-%Y_%H:%M:%S"))
                Title of the dataset. 

            Returns
            -------
            dict
                Content of the HTTP request as JSON.
        """
        zone = is_string(parameter=zone,
                         parameter_name="zone",
                         log=self._logging)

        ds: Datasets = Datasets(session=self.__session, 
                                suppress_print=self._suppress_print)
        
        storage_name, storage_resource = get_location_and_resource_by_zone(session=self.__session, 
                                                                           project=project, 
                                                                           zone=zone)
        
        content: dict[str, str | int] = ds.create_dataset(access=access,
                                                          project=project,
                                                          storage_resource=storage_resource,
                                                          storage_name=storage_name,
                                                          dataset_type=dataset_type,
                                                          additional_metadata=additional_metadata,
                                                          datacite=datacite,
                                                          title=title)
        
        return content
    

    def create_dataset_and_upload_directory(self,
                                            access: Access, 
                                            project: str,                                            
                                            local_directorypath: str,
                                            zone: str | None=None,
                                            dataset_directorypath: str | None=None,
                                            dataset_type : str | None=None,
                                            additional_metadata : dict | str | None=None,
                                            datacite: dict | None=None,
                                            title: str=str("UNTITLED_Dataset_" + datetime.now().strftime("%d-%m-%Y_%H:%M:%S"))) -> dict:
        """
            Creates an empty LEXIS dataset with specified attributes and perform upload of defined directory with subdirectories and data objects from local to LEXIS dataset via iRODS.
            If no dataset_path is defined, then path within the dataset will start by 'directory name' which has to be uploaded.
            Parallel transfer is automatically enabled for data objects with 32+ MB.
            
            NOTE: The method is based Datasets class in py4lexis.ddi.

            Parameters
            ----------
            access : Literal["public", "project", "user"], 
                One of the access types [public, project, user]
            project: str, 
                Project's shortname
            local_directorypath: str
                Path (absolute or relative) of a directory in local machine.
            dataset_directorypath : str | None
                Path (relative) within dataset to which a directory will be uploaded. If 'None', then by default is set to root.
            zone: str | None
                iRODS zonename. If None, then: 'IT4ILexisV2' is used.
            dataset_type : str | None=None,
                Type of the dataset (by default None). Example value can be 'dataset'
            additional_metadata : dict | str | None=None,
                Additional (arbitrary) metadata of the dataset. It should be keyword dictionary, 
                where key is the metadata name and value is the metadata value. Could be 
                also passed as JSON string.
            datacite: dict | None=None,
                Datacite metadata. It should correspond to the Datacite schema.
                In Py4Lexis, it can be generated by DataCite model.
            title: str
                Title of the dataset (by default untitled with datetime as ISO).
            
            Returns
            -------
            dict
                Content of create dataset response.
        """

        zone = is_string(parameter=zone,
                         parameter_name="zone",
                         log=self._logging)
        
        new_ds: dict = self.create_dataset(access=access,
                                           project=project,
                                           zone=zone,
                                           dataset_type=dataset_type,
                                           additional_metadata=additional_metadata,
                                           datacite=datacite,
                                           title=title)
        
        self.upload_directory_to_dataset(local_directorypath=local_directorypath,
                                         access=access,
                                         project=project,
                                         dataset_id=new_ds["dataset_id"],
                                         dataset_directorypath=dataset_directorypath,
                                         zone=zone)
        
        return new_ds

        
    @handle_class_exceptions()
    @handle_common_variables()
    def create_directory_within_dataset(self,
                                        dataset_directory_path: str,
                                        access: Access,
                                        project: str,
                                        dataset_id: str,
                                        zone: str | None=None,
                                        recurse: bool=True) -> iRODSCollection | None:
        """
            Creates a directory (collection) within LEXIS dataset via iRODS.

            Parameters
            ----------
            dataset_directory_path: str
                Path (relative) of a directory to be created within dataset, e.g. "./my_directory" or "./first_directory/second_directory".
            access: Literal["public", "project", "user"]
                Access type defined for a dataset.
            project: str
                LEXIS project's shortname.
            dataset_id: str
                Dataset's dataset ID (UUID).
            zone: str | None
                iRODS zonename. If None, then by default: 'IT4ILexisV2'.
            recurse: bool
                Use recurse option or not to create the collection. By default: True.

            Returns
            -------
            iRODSCollection | None
        """
        dataset_directory_path = is_string(parameter=dataset_directory_path,
                                           parameter_name="dataset_directory_path",
                                           log=self._logging)
        
        access = check_access(access=access,
                              log=self._logging)
        
        project = is_string(parameter=project,
                            parameter_name="project",
                            log=self._logging)
        
        dataset_id = check_if_uuid(uuid=dataset_id,
                                   parameter_name="dataset_id",
                                   log=self._logging)
        
        zone = is_string(parameter=zone,
                         parameter_name="zone",
                         log=self._logging)
        
        recurse = is_bool(parameter=recurse,
                          parameter_name="recurse",
                          log=self._logging)

        username: str | None = None
        if access == "user":
            username = self.__session._tokens.username
        
        irods_path: str = assemble_dataset_path(access=access,
                                                project=project,
                                                dataset_id=dataset_id,
                                                username=username)

        collection_irds_path: str = pure_path(dataset_directory_path)

        if collection_irds_path == "":
            raise Py4LexisiRODSException("No directory was defined to be created.")
        
        irods_path = f"/{zone}/{irods_path}/{collection_irds_path}"

        msg: str = f"Creating a new directory (collection): {irods_path}" 
        self._logging.info(msg)
        if not self._suppress_print:
            print(msg)

        collection: iRODSCollection = self.__irds.collections.create(irods_path, recurse)
        self._logging.info("Directory was created")

        if not self._suppress_print:
            print(f"New directory was successfully created...")

        return collection
    

    @handle_class_exceptions()
    @handle_common_variables()
    def get_project_collection(self,
                               access: Access,
                               project: str,
                               zone: str | None=None) -> iRODSCollection | None:
        """
            Gets LEXIS project as a collection.

            Parameters
            ----------
            access: Literal["public", "project", "user"]
                Access type defined for a dataset.
            project: str
                LEXIS project's shortname.
            zone: str | None
                iRODS zonename. If None, then by default: 'IT4ILexisV2'.

            Returns
            -------
            iRODSCollection | None
        """

        access = check_access(access=access,
                              log=self._logging)
        
        project = is_string(parameter=project,
                            parameter_name="project",
                            log=self._logging)
        
        zone = is_string(parameter=zone,
                         parameter_name="zone",
                         log=self._logging)

        username: str | None = None
        if access == "user":
            username = self.__session._tokens.username
        
        irods_path: str = assemble_dataset_path(access=access,
                                                project=project,
                                                username=username)
        
        irods_path = f"/{zone}/{irods_path}"

        msg: str = f"Getting directory (collection): {irods_path}"
        self._logging.info(msg) 
        if not self._suppress_print:
            print(msg)

        collection: iRODSCollection = self.__get_collection_with_log(irods_path, zone)
        self._logging.info("Directory was downloaded")

        if not self._suppress_print:
            print("Get collection was successfull...")

        return collection


    @handle_class_exceptions()
    @handle_common_variables()
    def get_dataset_collection(self,
                               access: Access,
                               project: str,
                               dataset_id: str,
                               zone: str | None=None) -> iRODSCollection | None:
        """
            Gets LEXIS dataset as a collection.

            Parameters
            ----------
            access: Literal["public", "project", "user"]
                Access type defined for a dataset.
            project: str
                LEXIS project's shortname.
            dataset_id: str
                Dataset's dataset ID (UUID).
            zone: str | None
                iRODS zonename. If None, then by default: 'IT4ILexisV2'.

            Returns
            -------
            iRODSCollection | None
        """                               
        username: str | None = None
        if access == "user":
            username = self.__session._tokens.username
        
        irods_path: str = assemble_dataset_path(access=access,
                                                project=project,
                                                dataset_id=dataset_id,
                                                username=username)

        irods_path = f"/{zone}/{irods_path}"
        
        msg: str = f"Getting directory (collection): {irods_path}" 
        self._logging.info(msg)
        if not self._suppress_print:
            print(msg)

        collection: iRODSCollection = self.__get_collection_with_log(irods_path, zone)
        self._logging.info("Directory was downloaded")

        if not self._suppress_print:
            print("Get collection was successfull...")

        return collection